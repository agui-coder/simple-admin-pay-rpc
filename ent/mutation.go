// Code generated by ent, DO NOT EDIT.

package ent

import (
	"context"
	"errors"
	"fmt"
	"github.com/agui-coder/simple-admin-pay-rpc/ent/app"
	"github.com/agui-coder/simple-admin-pay-rpc/ent/channel"
	"github.com/agui-coder/simple-admin-pay-rpc/ent/demoorder"
	"github.com/agui-coder/simple-admin-pay-rpc/ent/notifylog"
	"github.com/agui-coder/simple-admin-pay-rpc/ent/notifytask"
	"github.com/agui-coder/simple-admin-pay-rpc/ent/order"
	"github.com/agui-coder/simple-admin-pay-rpc/ent/orderextension"
	"github.com/agui-coder/simple-admin-pay-rpc/ent/predicate"
	"github.com/agui-coder/simple-admin-pay-rpc/ent/refund"
	"sync"
	"time"

	"entgo.io/ent"
	"entgo.io/ent/dialect/sql"
)

const (
	// Operation types.
	OpCreate    = ent.OpCreate
	OpDelete    = ent.OpDelete
	OpDeleteOne = ent.OpDeleteOne
	OpUpdate    = ent.OpUpdate
	OpUpdateOne = ent.OpUpdateOne

	// Node types.
	TypeApp            = "App"
	TypeChannel        = "Channel"
	TypeDemoOrder      = "DemoOrder"
	TypeNotifyLog      = "NotifyLog"
	TypeNotifyTask     = "NotifyTask"
	TypeOrder          = "Order"
	TypeOrderExtension = "OrderExtension"
	TypeRefund         = "Refund"
)

// AppMutation represents an operation that mutates the App nodes in the graph.
type AppMutation struct {
	config
	op                Op
	typ               string
	id                *uint64
	created_at        *time.Time
	updated_at        *time.Time
	status            *uint8
	addstatus         *int8
	deleted_at        *time.Time
	name              *string
	remark            *string
	order_notify_url  *string
	refund_notify_url *string
	clearedFields     map[string]struct{}
	done              bool
	oldValue          func(context.Context) (*App, error)
	predicates        []predicate.App
}

var _ ent.Mutation = (*AppMutation)(nil)

// appOption allows management of the mutation configuration using functional options.
type appOption func(*AppMutation)

// newAppMutation creates new mutation for the App entity.
func newAppMutation(c config, op Op, opts ...appOption) *AppMutation {
	m := &AppMutation{
		config:        c,
		op:            op,
		typ:           TypeApp,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withAppID sets the ID field of the mutation.
func withAppID(id uint64) appOption {
	return func(m *AppMutation) {
		var (
			err   error
			once  sync.Once
			value *App
		)
		m.oldValue = func(ctx context.Context) (*App, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().App.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withApp sets the old App of the mutation.
func withApp(node *App) appOption {
	return func(m *AppMutation) {
		m.oldValue = func(context.Context) (*App, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m AppMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m AppMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of App entities.
func (m *AppMutation) SetID(id uint64) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *AppMutation) ID() (id uint64, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *AppMutation) IDs(ctx context.Context) ([]uint64, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uint64{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().App.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *AppMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *AppMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the App entity.
// If the App object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AppMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *AppMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *AppMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *AppMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the App entity.
// If the App object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AppMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *AppMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetStatus sets the "status" field.
func (m *AppMutation) SetStatus(u uint8) {
	m.status = &u
	m.addstatus = nil
}

// Status returns the value of the "status" field in the mutation.
func (m *AppMutation) Status() (r uint8, exists bool) {
	v := m.status
	if v == nil {
		return
	}
	return *v, true
}

// OldStatus returns the old "status" field's value of the App entity.
// If the App object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AppMutation) OldStatus(ctx context.Context) (v uint8, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatus: %w", err)
	}
	return oldValue.Status, nil
}

// AddStatus adds u to the "status" field.
func (m *AppMutation) AddStatus(u int8) {
	if m.addstatus != nil {
		*m.addstatus += u
	} else {
		m.addstatus = &u
	}
}

// AddedStatus returns the value that was added to the "status" field in this mutation.
func (m *AppMutation) AddedStatus() (r int8, exists bool) {
	v := m.addstatus
	if v == nil {
		return
	}
	return *v, true
}

// ClearStatus clears the value of the "status" field.
func (m *AppMutation) ClearStatus() {
	m.status = nil
	m.addstatus = nil
	m.clearedFields[app.FieldStatus] = struct{}{}
}

// StatusCleared returns if the "status" field was cleared in this mutation.
func (m *AppMutation) StatusCleared() bool {
	_, ok := m.clearedFields[app.FieldStatus]
	return ok
}

// ResetStatus resets all changes to the "status" field.
func (m *AppMutation) ResetStatus() {
	m.status = nil
	m.addstatus = nil
	delete(m.clearedFields, app.FieldStatus)
}

// SetDeletedAt sets the "deleted_at" field.
func (m *AppMutation) SetDeletedAt(t time.Time) {
	m.deleted_at = &t
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *AppMutation) DeletedAt() (r time.Time, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the App entity.
// If the App object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AppMutation) OldDeletedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// ClearDeletedAt clears the value of the "deleted_at" field.
func (m *AppMutation) ClearDeletedAt() {
	m.deleted_at = nil
	m.clearedFields[app.FieldDeletedAt] = struct{}{}
}

// DeletedAtCleared returns if the "deleted_at" field was cleared in this mutation.
func (m *AppMutation) DeletedAtCleared() bool {
	_, ok := m.clearedFields[app.FieldDeletedAt]
	return ok
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *AppMutation) ResetDeletedAt() {
	m.deleted_at = nil
	delete(m.clearedFields, app.FieldDeletedAt)
}

// SetName sets the "name" field.
func (m *AppMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *AppMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the App entity.
// If the App object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AppMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *AppMutation) ResetName() {
	m.name = nil
}

// SetRemark sets the "remark" field.
func (m *AppMutation) SetRemark(s string) {
	m.remark = &s
}

// Remark returns the value of the "remark" field in the mutation.
func (m *AppMutation) Remark() (r string, exists bool) {
	v := m.remark
	if v == nil {
		return
	}
	return *v, true
}

// OldRemark returns the old "remark" field's value of the App entity.
// If the App object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AppMutation) OldRemark(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRemark is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRemark requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRemark: %w", err)
	}
	return oldValue.Remark, nil
}

// ClearRemark clears the value of the "remark" field.
func (m *AppMutation) ClearRemark() {
	m.remark = nil
	m.clearedFields[app.FieldRemark] = struct{}{}
}

// RemarkCleared returns if the "remark" field was cleared in this mutation.
func (m *AppMutation) RemarkCleared() bool {
	_, ok := m.clearedFields[app.FieldRemark]
	return ok
}

// ResetRemark resets all changes to the "remark" field.
func (m *AppMutation) ResetRemark() {
	m.remark = nil
	delete(m.clearedFields, app.FieldRemark)
}

// SetOrderNotifyURL sets the "order_notify_url" field.
func (m *AppMutation) SetOrderNotifyURL(s string) {
	m.order_notify_url = &s
}

// OrderNotifyURL returns the value of the "order_notify_url" field in the mutation.
func (m *AppMutation) OrderNotifyURL() (r string, exists bool) {
	v := m.order_notify_url
	if v == nil {
		return
	}
	return *v, true
}

// OldOrderNotifyURL returns the old "order_notify_url" field's value of the App entity.
// If the App object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AppMutation) OldOrderNotifyURL(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOrderNotifyURL is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOrderNotifyURL requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOrderNotifyURL: %w", err)
	}
	return oldValue.OrderNotifyURL, nil
}

// ResetOrderNotifyURL resets all changes to the "order_notify_url" field.
func (m *AppMutation) ResetOrderNotifyURL() {
	m.order_notify_url = nil
}

// SetRefundNotifyURL sets the "refund_notify_url" field.
func (m *AppMutation) SetRefundNotifyURL(s string) {
	m.refund_notify_url = &s
}

// RefundNotifyURL returns the value of the "refund_notify_url" field in the mutation.
func (m *AppMutation) RefundNotifyURL() (r string, exists bool) {
	v := m.refund_notify_url
	if v == nil {
		return
	}
	return *v, true
}

// OldRefundNotifyURL returns the old "refund_notify_url" field's value of the App entity.
// If the App object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AppMutation) OldRefundNotifyURL(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRefundNotifyURL is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRefundNotifyURL requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRefundNotifyURL: %w", err)
	}
	return oldValue.RefundNotifyURL, nil
}

// ResetRefundNotifyURL resets all changes to the "refund_notify_url" field.
func (m *AppMutation) ResetRefundNotifyURL() {
	m.refund_notify_url = nil
}

// Where appends a list predicates to the AppMutation builder.
func (m *AppMutation) Where(ps ...predicate.App) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the AppMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *AppMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.App, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *AppMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *AppMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (App).
func (m *AppMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *AppMutation) Fields() []string {
	fields := make([]string, 0, 8)
	if m.created_at != nil {
		fields = append(fields, app.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, app.FieldUpdatedAt)
	}
	if m.status != nil {
		fields = append(fields, app.FieldStatus)
	}
	if m.deleted_at != nil {
		fields = append(fields, app.FieldDeletedAt)
	}
	if m.name != nil {
		fields = append(fields, app.FieldName)
	}
	if m.remark != nil {
		fields = append(fields, app.FieldRemark)
	}
	if m.order_notify_url != nil {
		fields = append(fields, app.FieldOrderNotifyURL)
	}
	if m.refund_notify_url != nil {
		fields = append(fields, app.FieldRefundNotifyURL)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *AppMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case app.FieldCreatedAt:
		return m.CreatedAt()
	case app.FieldUpdatedAt:
		return m.UpdatedAt()
	case app.FieldStatus:
		return m.Status()
	case app.FieldDeletedAt:
		return m.DeletedAt()
	case app.FieldName:
		return m.Name()
	case app.FieldRemark:
		return m.Remark()
	case app.FieldOrderNotifyURL:
		return m.OrderNotifyURL()
	case app.FieldRefundNotifyURL:
		return m.RefundNotifyURL()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *AppMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case app.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case app.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case app.FieldStatus:
		return m.OldStatus(ctx)
	case app.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case app.FieldName:
		return m.OldName(ctx)
	case app.FieldRemark:
		return m.OldRemark(ctx)
	case app.FieldOrderNotifyURL:
		return m.OldOrderNotifyURL(ctx)
	case app.FieldRefundNotifyURL:
		return m.OldRefundNotifyURL(ctx)
	}
	return nil, fmt.Errorf("unknown App field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *AppMutation) SetField(name string, value ent.Value) error {
	switch name {
	case app.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case app.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case app.FieldStatus:
		v, ok := value.(uint8)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatus(v)
		return nil
	case app.FieldDeletedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case app.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case app.FieldRemark:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRemark(v)
		return nil
	case app.FieldOrderNotifyURL:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOrderNotifyURL(v)
		return nil
	case app.FieldRefundNotifyURL:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRefundNotifyURL(v)
		return nil
	}
	return fmt.Errorf("unknown App field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *AppMutation) AddedFields() []string {
	var fields []string
	if m.addstatus != nil {
		fields = append(fields, app.FieldStatus)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *AppMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case app.FieldStatus:
		return m.AddedStatus()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *AppMutation) AddField(name string, value ent.Value) error {
	switch name {
	case app.FieldStatus:
		v, ok := value.(int8)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddStatus(v)
		return nil
	}
	return fmt.Errorf("unknown App numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *AppMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(app.FieldStatus) {
		fields = append(fields, app.FieldStatus)
	}
	if m.FieldCleared(app.FieldDeletedAt) {
		fields = append(fields, app.FieldDeletedAt)
	}
	if m.FieldCleared(app.FieldRemark) {
		fields = append(fields, app.FieldRemark)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *AppMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *AppMutation) ClearField(name string) error {
	switch name {
	case app.FieldStatus:
		m.ClearStatus()
		return nil
	case app.FieldDeletedAt:
		m.ClearDeletedAt()
		return nil
	case app.FieldRemark:
		m.ClearRemark()
		return nil
	}
	return fmt.Errorf("unknown App nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *AppMutation) ResetField(name string) error {
	switch name {
	case app.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case app.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case app.FieldStatus:
		m.ResetStatus()
		return nil
	case app.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case app.FieldName:
		m.ResetName()
		return nil
	case app.FieldRemark:
		m.ResetRemark()
		return nil
	case app.FieldOrderNotifyURL:
		m.ResetOrderNotifyURL()
		return nil
	case app.FieldRefundNotifyURL:
		m.ResetRefundNotifyURL()
		return nil
	}
	return fmt.Errorf("unknown App field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *AppMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *AppMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *AppMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *AppMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *AppMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *AppMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *AppMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown App unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *AppMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown App edge %s", name)
}

// ChannelMutation represents an operation that mutates the Channel nodes in the graph.
type ChannelMutation struct {
	config
	op            Op
	typ           string
	id            *uint64
	created_at    *time.Time
	updated_at    *time.Time
	status        *uint8
	addstatus     *int8
	deleted_at    *time.Time
	code          *string
	remark        *string
	fee_rate      *float64
	addfee_rate   *float64
	app_id        *uint64
	addapp_id     *int64
	_config       *string
	clearedFields map[string]struct{}
	done          bool
	oldValue      func(context.Context) (*Channel, error)
	predicates    []predicate.Channel
}

var _ ent.Mutation = (*ChannelMutation)(nil)

// channelOption allows management of the mutation configuration using functional options.
type channelOption func(*ChannelMutation)

// newChannelMutation creates new mutation for the Channel entity.
func newChannelMutation(c config, op Op, opts ...channelOption) *ChannelMutation {
	m := &ChannelMutation{
		config:        c,
		op:            op,
		typ:           TypeChannel,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withChannelID sets the ID field of the mutation.
func withChannelID(id uint64) channelOption {
	return func(m *ChannelMutation) {
		var (
			err   error
			once  sync.Once
			value *Channel
		)
		m.oldValue = func(ctx context.Context) (*Channel, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Channel.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withChannel sets the old Channel of the mutation.
func withChannel(node *Channel) channelOption {
	return func(m *ChannelMutation) {
		m.oldValue = func(context.Context) (*Channel, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m ChannelMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m ChannelMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Channel entities.
func (m *ChannelMutation) SetID(id uint64) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *ChannelMutation) ID() (id uint64, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *ChannelMutation) IDs(ctx context.Context) ([]uint64, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uint64{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Channel.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *ChannelMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *ChannelMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Channel entity.
// If the Channel object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ChannelMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *ChannelMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *ChannelMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *ChannelMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Channel entity.
// If the Channel object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ChannelMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *ChannelMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetStatus sets the "status" field.
func (m *ChannelMutation) SetStatus(u uint8) {
	m.status = &u
	m.addstatus = nil
}

// Status returns the value of the "status" field in the mutation.
func (m *ChannelMutation) Status() (r uint8, exists bool) {
	v := m.status
	if v == nil {
		return
	}
	return *v, true
}

// OldStatus returns the old "status" field's value of the Channel entity.
// If the Channel object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ChannelMutation) OldStatus(ctx context.Context) (v uint8, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatus: %w", err)
	}
	return oldValue.Status, nil
}

// AddStatus adds u to the "status" field.
func (m *ChannelMutation) AddStatus(u int8) {
	if m.addstatus != nil {
		*m.addstatus += u
	} else {
		m.addstatus = &u
	}
}

// AddedStatus returns the value that was added to the "status" field in this mutation.
func (m *ChannelMutation) AddedStatus() (r int8, exists bool) {
	v := m.addstatus
	if v == nil {
		return
	}
	return *v, true
}

// ClearStatus clears the value of the "status" field.
func (m *ChannelMutation) ClearStatus() {
	m.status = nil
	m.addstatus = nil
	m.clearedFields[channel.FieldStatus] = struct{}{}
}

// StatusCleared returns if the "status" field was cleared in this mutation.
func (m *ChannelMutation) StatusCleared() bool {
	_, ok := m.clearedFields[channel.FieldStatus]
	return ok
}

// ResetStatus resets all changes to the "status" field.
func (m *ChannelMutation) ResetStatus() {
	m.status = nil
	m.addstatus = nil
	delete(m.clearedFields, channel.FieldStatus)
}

// SetDeletedAt sets the "deleted_at" field.
func (m *ChannelMutation) SetDeletedAt(t time.Time) {
	m.deleted_at = &t
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *ChannelMutation) DeletedAt() (r time.Time, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the Channel entity.
// If the Channel object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ChannelMutation) OldDeletedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// ClearDeletedAt clears the value of the "deleted_at" field.
func (m *ChannelMutation) ClearDeletedAt() {
	m.deleted_at = nil
	m.clearedFields[channel.FieldDeletedAt] = struct{}{}
}

// DeletedAtCleared returns if the "deleted_at" field was cleared in this mutation.
func (m *ChannelMutation) DeletedAtCleared() bool {
	_, ok := m.clearedFields[channel.FieldDeletedAt]
	return ok
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *ChannelMutation) ResetDeletedAt() {
	m.deleted_at = nil
	delete(m.clearedFields, channel.FieldDeletedAt)
}

// SetCode sets the "code" field.
func (m *ChannelMutation) SetCode(s string) {
	m.code = &s
}

// Code returns the value of the "code" field in the mutation.
func (m *ChannelMutation) Code() (r string, exists bool) {
	v := m.code
	if v == nil {
		return
	}
	return *v, true
}

// OldCode returns the old "code" field's value of the Channel entity.
// If the Channel object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ChannelMutation) OldCode(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCode is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCode requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCode: %w", err)
	}
	return oldValue.Code, nil
}

// ResetCode resets all changes to the "code" field.
func (m *ChannelMutation) ResetCode() {
	m.code = nil
}

// SetRemark sets the "remark" field.
func (m *ChannelMutation) SetRemark(s string) {
	m.remark = &s
}

// Remark returns the value of the "remark" field in the mutation.
func (m *ChannelMutation) Remark() (r string, exists bool) {
	v := m.remark
	if v == nil {
		return
	}
	return *v, true
}

// OldRemark returns the old "remark" field's value of the Channel entity.
// If the Channel object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ChannelMutation) OldRemark(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRemark is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRemark requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRemark: %w", err)
	}
	return oldValue.Remark, nil
}

// ClearRemark clears the value of the "remark" field.
func (m *ChannelMutation) ClearRemark() {
	m.remark = nil
	m.clearedFields[channel.FieldRemark] = struct{}{}
}

// RemarkCleared returns if the "remark" field was cleared in this mutation.
func (m *ChannelMutation) RemarkCleared() bool {
	_, ok := m.clearedFields[channel.FieldRemark]
	return ok
}

// ResetRemark resets all changes to the "remark" field.
func (m *ChannelMutation) ResetRemark() {
	m.remark = nil
	delete(m.clearedFields, channel.FieldRemark)
}

// SetFeeRate sets the "fee_rate" field.
func (m *ChannelMutation) SetFeeRate(f float64) {
	m.fee_rate = &f
	m.addfee_rate = nil
}

// FeeRate returns the value of the "fee_rate" field in the mutation.
func (m *ChannelMutation) FeeRate() (r float64, exists bool) {
	v := m.fee_rate
	if v == nil {
		return
	}
	return *v, true
}

// OldFeeRate returns the old "fee_rate" field's value of the Channel entity.
// If the Channel object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ChannelMutation) OldFeeRate(ctx context.Context) (v float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldFeeRate is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldFeeRate requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldFeeRate: %w", err)
	}
	return oldValue.FeeRate, nil
}

// AddFeeRate adds f to the "fee_rate" field.
func (m *ChannelMutation) AddFeeRate(f float64) {
	if m.addfee_rate != nil {
		*m.addfee_rate += f
	} else {
		m.addfee_rate = &f
	}
}

// AddedFeeRate returns the value that was added to the "fee_rate" field in this mutation.
func (m *ChannelMutation) AddedFeeRate() (r float64, exists bool) {
	v := m.addfee_rate
	if v == nil {
		return
	}
	return *v, true
}

// ResetFeeRate resets all changes to the "fee_rate" field.
func (m *ChannelMutation) ResetFeeRate() {
	m.fee_rate = nil
	m.addfee_rate = nil
}

// SetAppID sets the "app_id" field.
func (m *ChannelMutation) SetAppID(u uint64) {
	m.app_id = &u
	m.addapp_id = nil
}

// AppID returns the value of the "app_id" field in the mutation.
func (m *ChannelMutation) AppID() (r uint64, exists bool) {
	v := m.app_id
	if v == nil {
		return
	}
	return *v, true
}

// OldAppID returns the old "app_id" field's value of the Channel entity.
// If the Channel object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ChannelMutation) OldAppID(ctx context.Context) (v uint64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAppID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAppID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAppID: %w", err)
	}
	return oldValue.AppID, nil
}

// AddAppID adds u to the "app_id" field.
func (m *ChannelMutation) AddAppID(u int64) {
	if m.addapp_id != nil {
		*m.addapp_id += u
	} else {
		m.addapp_id = &u
	}
}

// AddedAppID returns the value that was added to the "app_id" field in this mutation.
func (m *ChannelMutation) AddedAppID() (r int64, exists bool) {
	v := m.addapp_id
	if v == nil {
		return
	}
	return *v, true
}

// ResetAppID resets all changes to the "app_id" field.
func (m *ChannelMutation) ResetAppID() {
	m.app_id = nil
	m.addapp_id = nil
}

// SetConfig sets the "config" field.
func (m *ChannelMutation) SetConfig(s string) {
	m._config = &s
}

// Config returns the value of the "config" field in the mutation.
func (m *ChannelMutation) Config() (r string, exists bool) {
	v := m._config
	if v == nil {
		return
	}
	return *v, true
}

// OldConfig returns the old "config" field's value of the Channel entity.
// If the Channel object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ChannelMutation) OldConfig(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldConfig is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldConfig requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldConfig: %w", err)
	}
	return oldValue.Config, nil
}

// ResetConfig resets all changes to the "config" field.
func (m *ChannelMutation) ResetConfig() {
	m._config = nil
}

// Where appends a list predicates to the ChannelMutation builder.
func (m *ChannelMutation) Where(ps ...predicate.Channel) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the ChannelMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *ChannelMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Channel, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *ChannelMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *ChannelMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Channel).
func (m *ChannelMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *ChannelMutation) Fields() []string {
	fields := make([]string, 0, 9)
	if m.created_at != nil {
		fields = append(fields, channel.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, channel.FieldUpdatedAt)
	}
	if m.status != nil {
		fields = append(fields, channel.FieldStatus)
	}
	if m.deleted_at != nil {
		fields = append(fields, channel.FieldDeletedAt)
	}
	if m.code != nil {
		fields = append(fields, channel.FieldCode)
	}
	if m.remark != nil {
		fields = append(fields, channel.FieldRemark)
	}
	if m.fee_rate != nil {
		fields = append(fields, channel.FieldFeeRate)
	}
	if m.app_id != nil {
		fields = append(fields, channel.FieldAppID)
	}
	if m._config != nil {
		fields = append(fields, channel.FieldConfig)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *ChannelMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case channel.FieldCreatedAt:
		return m.CreatedAt()
	case channel.FieldUpdatedAt:
		return m.UpdatedAt()
	case channel.FieldStatus:
		return m.Status()
	case channel.FieldDeletedAt:
		return m.DeletedAt()
	case channel.FieldCode:
		return m.Code()
	case channel.FieldRemark:
		return m.Remark()
	case channel.FieldFeeRate:
		return m.FeeRate()
	case channel.FieldAppID:
		return m.AppID()
	case channel.FieldConfig:
		return m.Config()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *ChannelMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case channel.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case channel.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case channel.FieldStatus:
		return m.OldStatus(ctx)
	case channel.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case channel.FieldCode:
		return m.OldCode(ctx)
	case channel.FieldRemark:
		return m.OldRemark(ctx)
	case channel.FieldFeeRate:
		return m.OldFeeRate(ctx)
	case channel.FieldAppID:
		return m.OldAppID(ctx)
	case channel.FieldConfig:
		return m.OldConfig(ctx)
	}
	return nil, fmt.Errorf("unknown Channel field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ChannelMutation) SetField(name string, value ent.Value) error {
	switch name {
	case channel.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case channel.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case channel.FieldStatus:
		v, ok := value.(uint8)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatus(v)
		return nil
	case channel.FieldDeletedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case channel.FieldCode:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCode(v)
		return nil
	case channel.FieldRemark:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRemark(v)
		return nil
	case channel.FieldFeeRate:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetFeeRate(v)
		return nil
	case channel.FieldAppID:
		v, ok := value.(uint64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAppID(v)
		return nil
	case channel.FieldConfig:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetConfig(v)
		return nil
	}
	return fmt.Errorf("unknown Channel field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *ChannelMutation) AddedFields() []string {
	var fields []string
	if m.addstatus != nil {
		fields = append(fields, channel.FieldStatus)
	}
	if m.addfee_rate != nil {
		fields = append(fields, channel.FieldFeeRate)
	}
	if m.addapp_id != nil {
		fields = append(fields, channel.FieldAppID)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *ChannelMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case channel.FieldStatus:
		return m.AddedStatus()
	case channel.FieldFeeRate:
		return m.AddedFeeRate()
	case channel.FieldAppID:
		return m.AddedAppID()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ChannelMutation) AddField(name string, value ent.Value) error {
	switch name {
	case channel.FieldStatus:
		v, ok := value.(int8)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddStatus(v)
		return nil
	case channel.FieldFeeRate:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddFeeRate(v)
		return nil
	case channel.FieldAppID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddAppID(v)
		return nil
	}
	return fmt.Errorf("unknown Channel numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *ChannelMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(channel.FieldStatus) {
		fields = append(fields, channel.FieldStatus)
	}
	if m.FieldCleared(channel.FieldDeletedAt) {
		fields = append(fields, channel.FieldDeletedAt)
	}
	if m.FieldCleared(channel.FieldRemark) {
		fields = append(fields, channel.FieldRemark)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *ChannelMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *ChannelMutation) ClearField(name string) error {
	switch name {
	case channel.FieldStatus:
		m.ClearStatus()
		return nil
	case channel.FieldDeletedAt:
		m.ClearDeletedAt()
		return nil
	case channel.FieldRemark:
		m.ClearRemark()
		return nil
	}
	return fmt.Errorf("unknown Channel nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *ChannelMutation) ResetField(name string) error {
	switch name {
	case channel.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case channel.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case channel.FieldStatus:
		m.ResetStatus()
		return nil
	case channel.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case channel.FieldCode:
		m.ResetCode()
		return nil
	case channel.FieldRemark:
		m.ResetRemark()
		return nil
	case channel.FieldFeeRate:
		m.ResetFeeRate()
		return nil
	case channel.FieldAppID:
		m.ResetAppID()
		return nil
	case channel.FieldConfig:
		m.ResetConfig()
		return nil
	}
	return fmt.Errorf("unknown Channel field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *ChannelMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *ChannelMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *ChannelMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *ChannelMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *ChannelMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *ChannelMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *ChannelMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown Channel unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *ChannelMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown Channel edge %s", name)
}

// DemoOrderMutation represents an operation that mutates the DemoOrder nodes in the graph.
type DemoOrderMutation struct {
	config
	op               Op
	typ              string
	id               *uint64
	created_at       *time.Time
	updated_at       *time.Time
	deleted_at       *time.Time
	user_id          *string
	spu_id           *uint64
	addspu_id        *int64
	spu_name         *string
	price            *int32
	addprice         *int32
	pay_status       *bool
	pay_orderId      *uint64
	addpay_orderId   *int64
	pay_time         *time.Time
	pay_channel_code *string
	pay_refund_id    *uint64
	addpay_refund_id *int64
	refund_price     *int32
	addrefund_price  *int32
	refund_time      *time.Time
	clearedFields    map[string]struct{}
	done             bool
	oldValue         func(context.Context) (*DemoOrder, error)
	predicates       []predicate.DemoOrder
}

var _ ent.Mutation = (*DemoOrderMutation)(nil)

// demoorderOption allows management of the mutation configuration using functional options.
type demoorderOption func(*DemoOrderMutation)

// newDemoOrderMutation creates new mutation for the DemoOrder entity.
func newDemoOrderMutation(c config, op Op, opts ...demoorderOption) *DemoOrderMutation {
	m := &DemoOrderMutation{
		config:        c,
		op:            op,
		typ:           TypeDemoOrder,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withDemoOrderID sets the ID field of the mutation.
func withDemoOrderID(id uint64) demoorderOption {
	return func(m *DemoOrderMutation) {
		var (
			err   error
			once  sync.Once
			value *DemoOrder
		)
		m.oldValue = func(ctx context.Context) (*DemoOrder, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().DemoOrder.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withDemoOrder sets the old DemoOrder of the mutation.
func withDemoOrder(node *DemoOrder) demoorderOption {
	return func(m *DemoOrderMutation) {
		m.oldValue = func(context.Context) (*DemoOrder, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m DemoOrderMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m DemoOrderMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of DemoOrder entities.
func (m *DemoOrderMutation) SetID(id uint64) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *DemoOrderMutation) ID() (id uint64, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *DemoOrderMutation) IDs(ctx context.Context) ([]uint64, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uint64{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().DemoOrder.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *DemoOrderMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *DemoOrderMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the DemoOrder entity.
// If the DemoOrder object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DemoOrderMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *DemoOrderMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *DemoOrderMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *DemoOrderMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the DemoOrder entity.
// If the DemoOrder object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DemoOrderMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *DemoOrderMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetDeletedAt sets the "deleted_at" field.
func (m *DemoOrderMutation) SetDeletedAt(t time.Time) {
	m.deleted_at = &t
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *DemoOrderMutation) DeletedAt() (r time.Time, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the DemoOrder entity.
// If the DemoOrder object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DemoOrderMutation) OldDeletedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// ClearDeletedAt clears the value of the "deleted_at" field.
func (m *DemoOrderMutation) ClearDeletedAt() {
	m.deleted_at = nil
	m.clearedFields[demoorder.FieldDeletedAt] = struct{}{}
}

// DeletedAtCleared returns if the "deleted_at" field was cleared in this mutation.
func (m *DemoOrderMutation) DeletedAtCleared() bool {
	_, ok := m.clearedFields[demoorder.FieldDeletedAt]
	return ok
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *DemoOrderMutation) ResetDeletedAt() {
	m.deleted_at = nil
	delete(m.clearedFields, demoorder.FieldDeletedAt)
}

// SetUserID sets the "user_id" field.
func (m *DemoOrderMutation) SetUserID(s string) {
	m.user_id = &s
}

// UserID returns the value of the "user_id" field in the mutation.
func (m *DemoOrderMutation) UserID() (r string, exists bool) {
	v := m.user_id
	if v == nil {
		return
	}
	return *v, true
}

// OldUserID returns the old "user_id" field's value of the DemoOrder entity.
// If the DemoOrder object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DemoOrderMutation) OldUserID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUserID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUserID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUserID: %w", err)
	}
	return oldValue.UserID, nil
}

// ResetUserID resets all changes to the "user_id" field.
func (m *DemoOrderMutation) ResetUserID() {
	m.user_id = nil
}

// SetSpuID sets the "spu_id" field.
func (m *DemoOrderMutation) SetSpuID(u uint64) {
	m.spu_id = &u
	m.addspu_id = nil
}

// SpuID returns the value of the "spu_id" field in the mutation.
func (m *DemoOrderMutation) SpuID() (r uint64, exists bool) {
	v := m.spu_id
	if v == nil {
		return
	}
	return *v, true
}

// OldSpuID returns the old "spu_id" field's value of the DemoOrder entity.
// If the DemoOrder object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DemoOrderMutation) OldSpuID(ctx context.Context) (v uint64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSpuID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSpuID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSpuID: %w", err)
	}
	return oldValue.SpuID, nil
}

// AddSpuID adds u to the "spu_id" field.
func (m *DemoOrderMutation) AddSpuID(u int64) {
	if m.addspu_id != nil {
		*m.addspu_id += u
	} else {
		m.addspu_id = &u
	}
}

// AddedSpuID returns the value that was added to the "spu_id" field in this mutation.
func (m *DemoOrderMutation) AddedSpuID() (r int64, exists bool) {
	v := m.addspu_id
	if v == nil {
		return
	}
	return *v, true
}

// ResetSpuID resets all changes to the "spu_id" field.
func (m *DemoOrderMutation) ResetSpuID() {
	m.spu_id = nil
	m.addspu_id = nil
}

// SetSpuName sets the "spu_name" field.
func (m *DemoOrderMutation) SetSpuName(s string) {
	m.spu_name = &s
}

// SpuName returns the value of the "spu_name" field in the mutation.
func (m *DemoOrderMutation) SpuName() (r string, exists bool) {
	v := m.spu_name
	if v == nil {
		return
	}
	return *v, true
}

// OldSpuName returns the old "spu_name" field's value of the DemoOrder entity.
// If the DemoOrder object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DemoOrderMutation) OldSpuName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSpuName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSpuName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSpuName: %w", err)
	}
	return oldValue.SpuName, nil
}

// ResetSpuName resets all changes to the "spu_name" field.
func (m *DemoOrderMutation) ResetSpuName() {
	m.spu_name = nil
}

// SetPrice sets the "price" field.
func (m *DemoOrderMutation) SetPrice(i int32) {
	m.price = &i
	m.addprice = nil
}

// Price returns the value of the "price" field in the mutation.
func (m *DemoOrderMutation) Price() (r int32, exists bool) {
	v := m.price
	if v == nil {
		return
	}
	return *v, true
}

// OldPrice returns the old "price" field's value of the DemoOrder entity.
// If the DemoOrder object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DemoOrderMutation) OldPrice(ctx context.Context) (v int32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPrice is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPrice requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPrice: %w", err)
	}
	return oldValue.Price, nil
}

// AddPrice adds i to the "price" field.
func (m *DemoOrderMutation) AddPrice(i int32) {
	if m.addprice != nil {
		*m.addprice += i
	} else {
		m.addprice = &i
	}
}

// AddedPrice returns the value that was added to the "price" field in this mutation.
func (m *DemoOrderMutation) AddedPrice() (r int32, exists bool) {
	v := m.addprice
	if v == nil {
		return
	}
	return *v, true
}

// ResetPrice resets all changes to the "price" field.
func (m *DemoOrderMutation) ResetPrice() {
	m.price = nil
	m.addprice = nil
}

// SetPayStatus sets the "pay_status" field.
func (m *DemoOrderMutation) SetPayStatus(b bool) {
	m.pay_status = &b
}

// PayStatus returns the value of the "pay_status" field in the mutation.
func (m *DemoOrderMutation) PayStatus() (r bool, exists bool) {
	v := m.pay_status
	if v == nil {
		return
	}
	return *v, true
}

// OldPayStatus returns the old "pay_status" field's value of the DemoOrder entity.
// If the DemoOrder object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DemoOrderMutation) OldPayStatus(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPayStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPayStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPayStatus: %w", err)
	}
	return oldValue.PayStatus, nil
}

// ResetPayStatus resets all changes to the "pay_status" field.
func (m *DemoOrderMutation) ResetPayStatus() {
	m.pay_status = nil
}

// SetPayOrderId sets the "pay_orderId" field.
func (m *DemoOrderMutation) SetPayOrderId(u uint64) {
	m.pay_orderId = &u
	m.addpay_orderId = nil
}

// PayOrderId returns the value of the "pay_orderId" field in the mutation.
func (m *DemoOrderMutation) PayOrderId() (r uint64, exists bool) {
	v := m.pay_orderId
	if v == nil {
		return
	}
	return *v, true
}

// OldPayOrderId returns the old "pay_orderId" field's value of the DemoOrder entity.
// If the DemoOrder object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DemoOrderMutation) OldPayOrderId(ctx context.Context) (v uint64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPayOrderId is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPayOrderId requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPayOrderId: %w", err)
	}
	return oldValue.PayOrderId, nil
}

// AddPayOrderId adds u to the "pay_orderId" field.
func (m *DemoOrderMutation) AddPayOrderId(u int64) {
	if m.addpay_orderId != nil {
		*m.addpay_orderId += u
	} else {
		m.addpay_orderId = &u
	}
}

// AddedPayOrderId returns the value that was added to the "pay_orderId" field in this mutation.
func (m *DemoOrderMutation) AddedPayOrderId() (r int64, exists bool) {
	v := m.addpay_orderId
	if v == nil {
		return
	}
	return *v, true
}

// ClearPayOrderId clears the value of the "pay_orderId" field.
func (m *DemoOrderMutation) ClearPayOrderId() {
	m.pay_orderId = nil
	m.addpay_orderId = nil
	m.clearedFields[demoorder.FieldPayOrderId] = struct{}{}
}

// PayOrderIdCleared returns if the "pay_orderId" field was cleared in this mutation.
func (m *DemoOrderMutation) PayOrderIdCleared() bool {
	_, ok := m.clearedFields[demoorder.FieldPayOrderId]
	return ok
}

// ResetPayOrderId resets all changes to the "pay_orderId" field.
func (m *DemoOrderMutation) ResetPayOrderId() {
	m.pay_orderId = nil
	m.addpay_orderId = nil
	delete(m.clearedFields, demoorder.FieldPayOrderId)
}

// SetPayTime sets the "pay_time" field.
func (m *DemoOrderMutation) SetPayTime(t time.Time) {
	m.pay_time = &t
}

// PayTime returns the value of the "pay_time" field in the mutation.
func (m *DemoOrderMutation) PayTime() (r time.Time, exists bool) {
	v := m.pay_time
	if v == nil {
		return
	}
	return *v, true
}

// OldPayTime returns the old "pay_time" field's value of the DemoOrder entity.
// If the DemoOrder object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DemoOrderMutation) OldPayTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPayTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPayTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPayTime: %w", err)
	}
	return oldValue.PayTime, nil
}

// ClearPayTime clears the value of the "pay_time" field.
func (m *DemoOrderMutation) ClearPayTime() {
	m.pay_time = nil
	m.clearedFields[demoorder.FieldPayTime] = struct{}{}
}

// PayTimeCleared returns if the "pay_time" field was cleared in this mutation.
func (m *DemoOrderMutation) PayTimeCleared() bool {
	_, ok := m.clearedFields[demoorder.FieldPayTime]
	return ok
}

// ResetPayTime resets all changes to the "pay_time" field.
func (m *DemoOrderMutation) ResetPayTime() {
	m.pay_time = nil
	delete(m.clearedFields, demoorder.FieldPayTime)
}

// SetPayChannelCode sets the "pay_channel_code" field.
func (m *DemoOrderMutation) SetPayChannelCode(s string) {
	m.pay_channel_code = &s
}

// PayChannelCode returns the value of the "pay_channel_code" field in the mutation.
func (m *DemoOrderMutation) PayChannelCode() (r string, exists bool) {
	v := m.pay_channel_code
	if v == nil {
		return
	}
	return *v, true
}

// OldPayChannelCode returns the old "pay_channel_code" field's value of the DemoOrder entity.
// If the DemoOrder object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DemoOrderMutation) OldPayChannelCode(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPayChannelCode is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPayChannelCode requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPayChannelCode: %w", err)
	}
	return oldValue.PayChannelCode, nil
}

// ClearPayChannelCode clears the value of the "pay_channel_code" field.
func (m *DemoOrderMutation) ClearPayChannelCode() {
	m.pay_channel_code = nil
	m.clearedFields[demoorder.FieldPayChannelCode] = struct{}{}
}

// PayChannelCodeCleared returns if the "pay_channel_code" field was cleared in this mutation.
func (m *DemoOrderMutation) PayChannelCodeCleared() bool {
	_, ok := m.clearedFields[demoorder.FieldPayChannelCode]
	return ok
}

// ResetPayChannelCode resets all changes to the "pay_channel_code" field.
func (m *DemoOrderMutation) ResetPayChannelCode() {
	m.pay_channel_code = nil
	delete(m.clearedFields, demoorder.FieldPayChannelCode)
}

// SetPayRefundID sets the "pay_refund_id" field.
func (m *DemoOrderMutation) SetPayRefundID(u uint64) {
	m.pay_refund_id = &u
	m.addpay_refund_id = nil
}

// PayRefundID returns the value of the "pay_refund_id" field in the mutation.
func (m *DemoOrderMutation) PayRefundID() (r uint64, exists bool) {
	v := m.pay_refund_id
	if v == nil {
		return
	}
	return *v, true
}

// OldPayRefundID returns the old "pay_refund_id" field's value of the DemoOrder entity.
// If the DemoOrder object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DemoOrderMutation) OldPayRefundID(ctx context.Context) (v uint64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPayRefundID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPayRefundID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPayRefundID: %w", err)
	}
	return oldValue.PayRefundID, nil
}

// AddPayRefundID adds u to the "pay_refund_id" field.
func (m *DemoOrderMutation) AddPayRefundID(u int64) {
	if m.addpay_refund_id != nil {
		*m.addpay_refund_id += u
	} else {
		m.addpay_refund_id = &u
	}
}

// AddedPayRefundID returns the value that was added to the "pay_refund_id" field in this mutation.
func (m *DemoOrderMutation) AddedPayRefundID() (r int64, exists bool) {
	v := m.addpay_refund_id
	if v == nil {
		return
	}
	return *v, true
}

// ClearPayRefundID clears the value of the "pay_refund_id" field.
func (m *DemoOrderMutation) ClearPayRefundID() {
	m.pay_refund_id = nil
	m.addpay_refund_id = nil
	m.clearedFields[demoorder.FieldPayRefundID] = struct{}{}
}

// PayRefundIDCleared returns if the "pay_refund_id" field was cleared in this mutation.
func (m *DemoOrderMutation) PayRefundIDCleared() bool {
	_, ok := m.clearedFields[demoorder.FieldPayRefundID]
	return ok
}

// ResetPayRefundID resets all changes to the "pay_refund_id" field.
func (m *DemoOrderMutation) ResetPayRefundID() {
	m.pay_refund_id = nil
	m.addpay_refund_id = nil
	delete(m.clearedFields, demoorder.FieldPayRefundID)
}

// SetRefundPrice sets the "refund_price" field.
func (m *DemoOrderMutation) SetRefundPrice(i int32) {
	m.refund_price = &i
	m.addrefund_price = nil
}

// RefundPrice returns the value of the "refund_price" field in the mutation.
func (m *DemoOrderMutation) RefundPrice() (r int32, exists bool) {
	v := m.refund_price
	if v == nil {
		return
	}
	return *v, true
}

// OldRefundPrice returns the old "refund_price" field's value of the DemoOrder entity.
// If the DemoOrder object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DemoOrderMutation) OldRefundPrice(ctx context.Context) (v int32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRefundPrice is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRefundPrice requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRefundPrice: %w", err)
	}
	return oldValue.RefundPrice, nil
}

// AddRefundPrice adds i to the "refund_price" field.
func (m *DemoOrderMutation) AddRefundPrice(i int32) {
	if m.addrefund_price != nil {
		*m.addrefund_price += i
	} else {
		m.addrefund_price = &i
	}
}

// AddedRefundPrice returns the value that was added to the "refund_price" field in this mutation.
func (m *DemoOrderMutation) AddedRefundPrice() (r int32, exists bool) {
	v := m.addrefund_price
	if v == nil {
		return
	}
	return *v, true
}

// ClearRefundPrice clears the value of the "refund_price" field.
func (m *DemoOrderMutation) ClearRefundPrice() {
	m.refund_price = nil
	m.addrefund_price = nil
	m.clearedFields[demoorder.FieldRefundPrice] = struct{}{}
}

// RefundPriceCleared returns if the "refund_price" field was cleared in this mutation.
func (m *DemoOrderMutation) RefundPriceCleared() bool {
	_, ok := m.clearedFields[demoorder.FieldRefundPrice]
	return ok
}

// ResetRefundPrice resets all changes to the "refund_price" field.
func (m *DemoOrderMutation) ResetRefundPrice() {
	m.refund_price = nil
	m.addrefund_price = nil
	delete(m.clearedFields, demoorder.FieldRefundPrice)
}

// SetRefundTime sets the "refund_time" field.
func (m *DemoOrderMutation) SetRefundTime(t time.Time) {
	m.refund_time = &t
}

// RefundTime returns the value of the "refund_time" field in the mutation.
func (m *DemoOrderMutation) RefundTime() (r time.Time, exists bool) {
	v := m.refund_time
	if v == nil {
		return
	}
	return *v, true
}

// OldRefundTime returns the old "refund_time" field's value of the DemoOrder entity.
// If the DemoOrder object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DemoOrderMutation) OldRefundTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRefundTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRefundTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRefundTime: %w", err)
	}
	return oldValue.RefundTime, nil
}

// ClearRefundTime clears the value of the "refund_time" field.
func (m *DemoOrderMutation) ClearRefundTime() {
	m.refund_time = nil
	m.clearedFields[demoorder.FieldRefundTime] = struct{}{}
}

// RefundTimeCleared returns if the "refund_time" field was cleared in this mutation.
func (m *DemoOrderMutation) RefundTimeCleared() bool {
	_, ok := m.clearedFields[demoorder.FieldRefundTime]
	return ok
}

// ResetRefundTime resets all changes to the "refund_time" field.
func (m *DemoOrderMutation) ResetRefundTime() {
	m.refund_time = nil
	delete(m.clearedFields, demoorder.FieldRefundTime)
}

// Where appends a list predicates to the DemoOrderMutation builder.
func (m *DemoOrderMutation) Where(ps ...predicate.DemoOrder) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the DemoOrderMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *DemoOrderMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.DemoOrder, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *DemoOrderMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *DemoOrderMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (DemoOrder).
func (m *DemoOrderMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *DemoOrderMutation) Fields() []string {
	fields := make([]string, 0, 14)
	if m.created_at != nil {
		fields = append(fields, demoorder.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, demoorder.FieldUpdatedAt)
	}
	if m.deleted_at != nil {
		fields = append(fields, demoorder.FieldDeletedAt)
	}
	if m.user_id != nil {
		fields = append(fields, demoorder.FieldUserID)
	}
	if m.spu_id != nil {
		fields = append(fields, demoorder.FieldSpuID)
	}
	if m.spu_name != nil {
		fields = append(fields, demoorder.FieldSpuName)
	}
	if m.price != nil {
		fields = append(fields, demoorder.FieldPrice)
	}
	if m.pay_status != nil {
		fields = append(fields, demoorder.FieldPayStatus)
	}
	if m.pay_orderId != nil {
		fields = append(fields, demoorder.FieldPayOrderId)
	}
	if m.pay_time != nil {
		fields = append(fields, demoorder.FieldPayTime)
	}
	if m.pay_channel_code != nil {
		fields = append(fields, demoorder.FieldPayChannelCode)
	}
	if m.pay_refund_id != nil {
		fields = append(fields, demoorder.FieldPayRefundID)
	}
	if m.refund_price != nil {
		fields = append(fields, demoorder.FieldRefundPrice)
	}
	if m.refund_time != nil {
		fields = append(fields, demoorder.FieldRefundTime)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *DemoOrderMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case demoorder.FieldCreatedAt:
		return m.CreatedAt()
	case demoorder.FieldUpdatedAt:
		return m.UpdatedAt()
	case demoorder.FieldDeletedAt:
		return m.DeletedAt()
	case demoorder.FieldUserID:
		return m.UserID()
	case demoorder.FieldSpuID:
		return m.SpuID()
	case demoorder.FieldSpuName:
		return m.SpuName()
	case demoorder.FieldPrice:
		return m.Price()
	case demoorder.FieldPayStatus:
		return m.PayStatus()
	case demoorder.FieldPayOrderId:
		return m.PayOrderId()
	case demoorder.FieldPayTime:
		return m.PayTime()
	case demoorder.FieldPayChannelCode:
		return m.PayChannelCode()
	case demoorder.FieldPayRefundID:
		return m.PayRefundID()
	case demoorder.FieldRefundPrice:
		return m.RefundPrice()
	case demoorder.FieldRefundTime:
		return m.RefundTime()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *DemoOrderMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case demoorder.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case demoorder.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case demoorder.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case demoorder.FieldUserID:
		return m.OldUserID(ctx)
	case demoorder.FieldSpuID:
		return m.OldSpuID(ctx)
	case demoorder.FieldSpuName:
		return m.OldSpuName(ctx)
	case demoorder.FieldPrice:
		return m.OldPrice(ctx)
	case demoorder.FieldPayStatus:
		return m.OldPayStatus(ctx)
	case demoorder.FieldPayOrderId:
		return m.OldPayOrderId(ctx)
	case demoorder.FieldPayTime:
		return m.OldPayTime(ctx)
	case demoorder.FieldPayChannelCode:
		return m.OldPayChannelCode(ctx)
	case demoorder.FieldPayRefundID:
		return m.OldPayRefundID(ctx)
	case demoorder.FieldRefundPrice:
		return m.OldRefundPrice(ctx)
	case demoorder.FieldRefundTime:
		return m.OldRefundTime(ctx)
	}
	return nil, fmt.Errorf("unknown DemoOrder field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *DemoOrderMutation) SetField(name string, value ent.Value) error {
	switch name {
	case demoorder.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case demoorder.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case demoorder.FieldDeletedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case demoorder.FieldUserID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUserID(v)
		return nil
	case demoorder.FieldSpuID:
		v, ok := value.(uint64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSpuID(v)
		return nil
	case demoorder.FieldSpuName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSpuName(v)
		return nil
	case demoorder.FieldPrice:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPrice(v)
		return nil
	case demoorder.FieldPayStatus:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPayStatus(v)
		return nil
	case demoorder.FieldPayOrderId:
		v, ok := value.(uint64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPayOrderId(v)
		return nil
	case demoorder.FieldPayTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPayTime(v)
		return nil
	case demoorder.FieldPayChannelCode:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPayChannelCode(v)
		return nil
	case demoorder.FieldPayRefundID:
		v, ok := value.(uint64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPayRefundID(v)
		return nil
	case demoorder.FieldRefundPrice:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRefundPrice(v)
		return nil
	case demoorder.FieldRefundTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRefundTime(v)
		return nil
	}
	return fmt.Errorf("unknown DemoOrder field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *DemoOrderMutation) AddedFields() []string {
	var fields []string
	if m.addspu_id != nil {
		fields = append(fields, demoorder.FieldSpuID)
	}
	if m.addprice != nil {
		fields = append(fields, demoorder.FieldPrice)
	}
	if m.addpay_orderId != nil {
		fields = append(fields, demoorder.FieldPayOrderId)
	}
	if m.addpay_refund_id != nil {
		fields = append(fields, demoorder.FieldPayRefundID)
	}
	if m.addrefund_price != nil {
		fields = append(fields, demoorder.FieldRefundPrice)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *DemoOrderMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case demoorder.FieldSpuID:
		return m.AddedSpuID()
	case demoorder.FieldPrice:
		return m.AddedPrice()
	case demoorder.FieldPayOrderId:
		return m.AddedPayOrderId()
	case demoorder.FieldPayRefundID:
		return m.AddedPayRefundID()
	case demoorder.FieldRefundPrice:
		return m.AddedRefundPrice()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *DemoOrderMutation) AddField(name string, value ent.Value) error {
	switch name {
	case demoorder.FieldSpuID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddSpuID(v)
		return nil
	case demoorder.FieldPrice:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddPrice(v)
		return nil
	case demoorder.FieldPayOrderId:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddPayOrderId(v)
		return nil
	case demoorder.FieldPayRefundID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddPayRefundID(v)
		return nil
	case demoorder.FieldRefundPrice:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddRefundPrice(v)
		return nil
	}
	return fmt.Errorf("unknown DemoOrder numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *DemoOrderMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(demoorder.FieldDeletedAt) {
		fields = append(fields, demoorder.FieldDeletedAt)
	}
	if m.FieldCleared(demoorder.FieldPayOrderId) {
		fields = append(fields, demoorder.FieldPayOrderId)
	}
	if m.FieldCleared(demoorder.FieldPayTime) {
		fields = append(fields, demoorder.FieldPayTime)
	}
	if m.FieldCleared(demoorder.FieldPayChannelCode) {
		fields = append(fields, demoorder.FieldPayChannelCode)
	}
	if m.FieldCleared(demoorder.FieldPayRefundID) {
		fields = append(fields, demoorder.FieldPayRefundID)
	}
	if m.FieldCleared(demoorder.FieldRefundPrice) {
		fields = append(fields, demoorder.FieldRefundPrice)
	}
	if m.FieldCleared(demoorder.FieldRefundTime) {
		fields = append(fields, demoorder.FieldRefundTime)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *DemoOrderMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *DemoOrderMutation) ClearField(name string) error {
	switch name {
	case demoorder.FieldDeletedAt:
		m.ClearDeletedAt()
		return nil
	case demoorder.FieldPayOrderId:
		m.ClearPayOrderId()
		return nil
	case demoorder.FieldPayTime:
		m.ClearPayTime()
		return nil
	case demoorder.FieldPayChannelCode:
		m.ClearPayChannelCode()
		return nil
	case demoorder.FieldPayRefundID:
		m.ClearPayRefundID()
		return nil
	case demoorder.FieldRefundPrice:
		m.ClearRefundPrice()
		return nil
	case demoorder.FieldRefundTime:
		m.ClearRefundTime()
		return nil
	}
	return fmt.Errorf("unknown DemoOrder nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *DemoOrderMutation) ResetField(name string) error {
	switch name {
	case demoorder.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case demoorder.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case demoorder.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case demoorder.FieldUserID:
		m.ResetUserID()
		return nil
	case demoorder.FieldSpuID:
		m.ResetSpuID()
		return nil
	case demoorder.FieldSpuName:
		m.ResetSpuName()
		return nil
	case demoorder.FieldPrice:
		m.ResetPrice()
		return nil
	case demoorder.FieldPayStatus:
		m.ResetPayStatus()
		return nil
	case demoorder.FieldPayOrderId:
		m.ResetPayOrderId()
		return nil
	case demoorder.FieldPayTime:
		m.ResetPayTime()
		return nil
	case demoorder.FieldPayChannelCode:
		m.ResetPayChannelCode()
		return nil
	case demoorder.FieldPayRefundID:
		m.ResetPayRefundID()
		return nil
	case demoorder.FieldRefundPrice:
		m.ResetRefundPrice()
		return nil
	case demoorder.FieldRefundTime:
		m.ResetRefundTime()
		return nil
	}
	return fmt.Errorf("unknown DemoOrder field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *DemoOrderMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *DemoOrderMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *DemoOrderMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *DemoOrderMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *DemoOrderMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *DemoOrderMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *DemoOrderMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown DemoOrder unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *DemoOrderMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown DemoOrder edge %s", name)
}

// NotifyLogMutation represents an operation that mutates the NotifyLog nodes in the graph.
type NotifyLogMutation struct {
	config
	op              Op
	typ             string
	id              *uint64
	created_at      *time.Time
	updated_at      *time.Time
	status          *uint8
	addstatus       *int8
	deleted_at      *time.Time
	task_id         *uint64
	addtask_id      *int64
	notify_times    *int8
	addnotify_times *int8
	response        *string
	clearedFields   map[string]struct{}
	done            bool
	oldValue        func(context.Context) (*NotifyLog, error)
	predicates      []predicate.NotifyLog
}

var _ ent.Mutation = (*NotifyLogMutation)(nil)

// notifylogOption allows management of the mutation configuration using functional options.
type notifylogOption func(*NotifyLogMutation)

// newNotifyLogMutation creates new mutation for the NotifyLog entity.
func newNotifyLogMutation(c config, op Op, opts ...notifylogOption) *NotifyLogMutation {
	m := &NotifyLogMutation{
		config:        c,
		op:            op,
		typ:           TypeNotifyLog,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withNotifyLogID sets the ID field of the mutation.
func withNotifyLogID(id uint64) notifylogOption {
	return func(m *NotifyLogMutation) {
		var (
			err   error
			once  sync.Once
			value *NotifyLog
		)
		m.oldValue = func(ctx context.Context) (*NotifyLog, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().NotifyLog.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withNotifyLog sets the old NotifyLog of the mutation.
func withNotifyLog(node *NotifyLog) notifylogOption {
	return func(m *NotifyLogMutation) {
		m.oldValue = func(context.Context) (*NotifyLog, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m NotifyLogMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m NotifyLogMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of NotifyLog entities.
func (m *NotifyLogMutation) SetID(id uint64) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *NotifyLogMutation) ID() (id uint64, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *NotifyLogMutation) IDs(ctx context.Context) ([]uint64, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uint64{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().NotifyLog.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *NotifyLogMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *NotifyLogMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the NotifyLog entity.
// If the NotifyLog object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *NotifyLogMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *NotifyLogMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *NotifyLogMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *NotifyLogMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the NotifyLog entity.
// If the NotifyLog object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *NotifyLogMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *NotifyLogMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetStatus sets the "status" field.
func (m *NotifyLogMutation) SetStatus(u uint8) {
	m.status = &u
	m.addstatus = nil
}

// Status returns the value of the "status" field in the mutation.
func (m *NotifyLogMutation) Status() (r uint8, exists bool) {
	v := m.status
	if v == nil {
		return
	}
	return *v, true
}

// OldStatus returns the old "status" field's value of the NotifyLog entity.
// If the NotifyLog object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *NotifyLogMutation) OldStatus(ctx context.Context) (v uint8, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatus: %w", err)
	}
	return oldValue.Status, nil
}

// AddStatus adds u to the "status" field.
func (m *NotifyLogMutation) AddStatus(u int8) {
	if m.addstatus != nil {
		*m.addstatus += u
	} else {
		m.addstatus = &u
	}
}

// AddedStatus returns the value that was added to the "status" field in this mutation.
func (m *NotifyLogMutation) AddedStatus() (r int8, exists bool) {
	v := m.addstatus
	if v == nil {
		return
	}
	return *v, true
}

// ClearStatus clears the value of the "status" field.
func (m *NotifyLogMutation) ClearStatus() {
	m.status = nil
	m.addstatus = nil
	m.clearedFields[notifylog.FieldStatus] = struct{}{}
}

// StatusCleared returns if the "status" field was cleared in this mutation.
func (m *NotifyLogMutation) StatusCleared() bool {
	_, ok := m.clearedFields[notifylog.FieldStatus]
	return ok
}

// ResetStatus resets all changes to the "status" field.
func (m *NotifyLogMutation) ResetStatus() {
	m.status = nil
	m.addstatus = nil
	delete(m.clearedFields, notifylog.FieldStatus)
}

// SetDeletedAt sets the "deleted_at" field.
func (m *NotifyLogMutation) SetDeletedAt(t time.Time) {
	m.deleted_at = &t
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *NotifyLogMutation) DeletedAt() (r time.Time, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the NotifyLog entity.
// If the NotifyLog object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *NotifyLogMutation) OldDeletedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// ClearDeletedAt clears the value of the "deleted_at" field.
func (m *NotifyLogMutation) ClearDeletedAt() {
	m.deleted_at = nil
	m.clearedFields[notifylog.FieldDeletedAt] = struct{}{}
}

// DeletedAtCleared returns if the "deleted_at" field was cleared in this mutation.
func (m *NotifyLogMutation) DeletedAtCleared() bool {
	_, ok := m.clearedFields[notifylog.FieldDeletedAt]
	return ok
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *NotifyLogMutation) ResetDeletedAt() {
	m.deleted_at = nil
	delete(m.clearedFields, notifylog.FieldDeletedAt)
}

// SetTaskID sets the "task_id" field.
func (m *NotifyLogMutation) SetTaskID(u uint64) {
	m.task_id = &u
	m.addtask_id = nil
}

// TaskID returns the value of the "task_id" field in the mutation.
func (m *NotifyLogMutation) TaskID() (r uint64, exists bool) {
	v := m.task_id
	if v == nil {
		return
	}
	return *v, true
}

// OldTaskID returns the old "task_id" field's value of the NotifyLog entity.
// If the NotifyLog object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *NotifyLogMutation) OldTaskID(ctx context.Context) (v uint64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTaskID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTaskID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTaskID: %w", err)
	}
	return oldValue.TaskID, nil
}

// AddTaskID adds u to the "task_id" field.
func (m *NotifyLogMutation) AddTaskID(u int64) {
	if m.addtask_id != nil {
		*m.addtask_id += u
	} else {
		m.addtask_id = &u
	}
}

// AddedTaskID returns the value that was added to the "task_id" field in this mutation.
func (m *NotifyLogMutation) AddedTaskID() (r int64, exists bool) {
	v := m.addtask_id
	if v == nil {
		return
	}
	return *v, true
}

// ResetTaskID resets all changes to the "task_id" field.
func (m *NotifyLogMutation) ResetTaskID() {
	m.task_id = nil
	m.addtask_id = nil
}

// SetNotifyTimes sets the "notify_times" field.
func (m *NotifyLogMutation) SetNotifyTimes(i int8) {
	m.notify_times = &i
	m.addnotify_times = nil
}

// NotifyTimes returns the value of the "notify_times" field in the mutation.
func (m *NotifyLogMutation) NotifyTimes() (r int8, exists bool) {
	v := m.notify_times
	if v == nil {
		return
	}
	return *v, true
}

// OldNotifyTimes returns the old "notify_times" field's value of the NotifyLog entity.
// If the NotifyLog object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *NotifyLogMutation) OldNotifyTimes(ctx context.Context) (v int8, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldNotifyTimes is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldNotifyTimes requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldNotifyTimes: %w", err)
	}
	return oldValue.NotifyTimes, nil
}

// AddNotifyTimes adds i to the "notify_times" field.
func (m *NotifyLogMutation) AddNotifyTimes(i int8) {
	if m.addnotify_times != nil {
		*m.addnotify_times += i
	} else {
		m.addnotify_times = &i
	}
}

// AddedNotifyTimes returns the value that was added to the "notify_times" field in this mutation.
func (m *NotifyLogMutation) AddedNotifyTimes() (r int8, exists bool) {
	v := m.addnotify_times
	if v == nil {
		return
	}
	return *v, true
}

// ResetNotifyTimes resets all changes to the "notify_times" field.
func (m *NotifyLogMutation) ResetNotifyTimes() {
	m.notify_times = nil
	m.addnotify_times = nil
}

// SetResponse sets the "response" field.
func (m *NotifyLogMutation) SetResponse(s string) {
	m.response = &s
}

// Response returns the value of the "response" field in the mutation.
func (m *NotifyLogMutation) Response() (r string, exists bool) {
	v := m.response
	if v == nil {
		return
	}
	return *v, true
}

// OldResponse returns the old "response" field's value of the NotifyLog entity.
// If the NotifyLog object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *NotifyLogMutation) OldResponse(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldResponse is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldResponse requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldResponse: %w", err)
	}
	return oldValue.Response, nil
}

// ResetResponse resets all changes to the "response" field.
func (m *NotifyLogMutation) ResetResponse() {
	m.response = nil
}

// Where appends a list predicates to the NotifyLogMutation builder.
func (m *NotifyLogMutation) Where(ps ...predicate.NotifyLog) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the NotifyLogMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *NotifyLogMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.NotifyLog, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *NotifyLogMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *NotifyLogMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (NotifyLog).
func (m *NotifyLogMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *NotifyLogMutation) Fields() []string {
	fields := make([]string, 0, 7)
	if m.created_at != nil {
		fields = append(fields, notifylog.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, notifylog.FieldUpdatedAt)
	}
	if m.status != nil {
		fields = append(fields, notifylog.FieldStatus)
	}
	if m.deleted_at != nil {
		fields = append(fields, notifylog.FieldDeletedAt)
	}
	if m.task_id != nil {
		fields = append(fields, notifylog.FieldTaskID)
	}
	if m.notify_times != nil {
		fields = append(fields, notifylog.FieldNotifyTimes)
	}
	if m.response != nil {
		fields = append(fields, notifylog.FieldResponse)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *NotifyLogMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case notifylog.FieldCreatedAt:
		return m.CreatedAt()
	case notifylog.FieldUpdatedAt:
		return m.UpdatedAt()
	case notifylog.FieldStatus:
		return m.Status()
	case notifylog.FieldDeletedAt:
		return m.DeletedAt()
	case notifylog.FieldTaskID:
		return m.TaskID()
	case notifylog.FieldNotifyTimes:
		return m.NotifyTimes()
	case notifylog.FieldResponse:
		return m.Response()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *NotifyLogMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case notifylog.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case notifylog.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case notifylog.FieldStatus:
		return m.OldStatus(ctx)
	case notifylog.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case notifylog.FieldTaskID:
		return m.OldTaskID(ctx)
	case notifylog.FieldNotifyTimes:
		return m.OldNotifyTimes(ctx)
	case notifylog.FieldResponse:
		return m.OldResponse(ctx)
	}
	return nil, fmt.Errorf("unknown NotifyLog field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *NotifyLogMutation) SetField(name string, value ent.Value) error {
	switch name {
	case notifylog.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case notifylog.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case notifylog.FieldStatus:
		v, ok := value.(uint8)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatus(v)
		return nil
	case notifylog.FieldDeletedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case notifylog.FieldTaskID:
		v, ok := value.(uint64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTaskID(v)
		return nil
	case notifylog.FieldNotifyTimes:
		v, ok := value.(int8)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetNotifyTimes(v)
		return nil
	case notifylog.FieldResponse:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetResponse(v)
		return nil
	}
	return fmt.Errorf("unknown NotifyLog field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *NotifyLogMutation) AddedFields() []string {
	var fields []string
	if m.addstatus != nil {
		fields = append(fields, notifylog.FieldStatus)
	}
	if m.addtask_id != nil {
		fields = append(fields, notifylog.FieldTaskID)
	}
	if m.addnotify_times != nil {
		fields = append(fields, notifylog.FieldNotifyTimes)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *NotifyLogMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case notifylog.FieldStatus:
		return m.AddedStatus()
	case notifylog.FieldTaskID:
		return m.AddedTaskID()
	case notifylog.FieldNotifyTimes:
		return m.AddedNotifyTimes()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *NotifyLogMutation) AddField(name string, value ent.Value) error {
	switch name {
	case notifylog.FieldStatus:
		v, ok := value.(int8)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddStatus(v)
		return nil
	case notifylog.FieldTaskID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddTaskID(v)
		return nil
	case notifylog.FieldNotifyTimes:
		v, ok := value.(int8)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddNotifyTimes(v)
		return nil
	}
	return fmt.Errorf("unknown NotifyLog numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *NotifyLogMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(notifylog.FieldStatus) {
		fields = append(fields, notifylog.FieldStatus)
	}
	if m.FieldCleared(notifylog.FieldDeletedAt) {
		fields = append(fields, notifylog.FieldDeletedAt)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *NotifyLogMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *NotifyLogMutation) ClearField(name string) error {
	switch name {
	case notifylog.FieldStatus:
		m.ClearStatus()
		return nil
	case notifylog.FieldDeletedAt:
		m.ClearDeletedAt()
		return nil
	}
	return fmt.Errorf("unknown NotifyLog nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *NotifyLogMutation) ResetField(name string) error {
	switch name {
	case notifylog.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case notifylog.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case notifylog.FieldStatus:
		m.ResetStatus()
		return nil
	case notifylog.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case notifylog.FieldTaskID:
		m.ResetTaskID()
		return nil
	case notifylog.FieldNotifyTimes:
		m.ResetNotifyTimes()
		return nil
	case notifylog.FieldResponse:
		m.ResetResponse()
		return nil
	}
	return fmt.Errorf("unknown NotifyLog field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *NotifyLogMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *NotifyLogMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *NotifyLogMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *NotifyLogMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *NotifyLogMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *NotifyLogMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *NotifyLogMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown NotifyLog unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *NotifyLogMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown NotifyLog edge %s", name)
}

// NotifyTaskMutation represents an operation that mutates the NotifyTask nodes in the graph.
type NotifyTaskMutation struct {
	config
	op                  Op
	typ                 string
	id                  *uint64
	created_at          *time.Time
	updated_at          *time.Time
	status              *uint8
	addstatus           *int8
	deleted_at          *time.Time
	app_id              *uint64
	addapp_id           *int64
	_type               *int
	add_type            *int
	data_id             *uint64
	adddata_id          *int64
	merchant_order_id   *string
	next_notify_time    *time.Time
	last_execute_time   *time.Time
	notify_times        *int8
	addnotify_times     *int8
	max_notify_times    *int8
	addmax_notify_times *int8
	notify_url          *string
	clearedFields       map[string]struct{}
	done                bool
	oldValue            func(context.Context) (*NotifyTask, error)
	predicates          []predicate.NotifyTask
}

var _ ent.Mutation = (*NotifyTaskMutation)(nil)

// notifytaskOption allows management of the mutation configuration using functional options.
type notifytaskOption func(*NotifyTaskMutation)

// newNotifyTaskMutation creates new mutation for the NotifyTask entity.
func newNotifyTaskMutation(c config, op Op, opts ...notifytaskOption) *NotifyTaskMutation {
	m := &NotifyTaskMutation{
		config:        c,
		op:            op,
		typ:           TypeNotifyTask,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withNotifyTaskID sets the ID field of the mutation.
func withNotifyTaskID(id uint64) notifytaskOption {
	return func(m *NotifyTaskMutation) {
		var (
			err   error
			once  sync.Once
			value *NotifyTask
		)
		m.oldValue = func(ctx context.Context) (*NotifyTask, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().NotifyTask.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withNotifyTask sets the old NotifyTask of the mutation.
func withNotifyTask(node *NotifyTask) notifytaskOption {
	return func(m *NotifyTaskMutation) {
		m.oldValue = func(context.Context) (*NotifyTask, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m NotifyTaskMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m NotifyTaskMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of NotifyTask entities.
func (m *NotifyTaskMutation) SetID(id uint64) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *NotifyTaskMutation) ID() (id uint64, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *NotifyTaskMutation) IDs(ctx context.Context) ([]uint64, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uint64{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().NotifyTask.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *NotifyTaskMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *NotifyTaskMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the NotifyTask entity.
// If the NotifyTask object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *NotifyTaskMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *NotifyTaskMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *NotifyTaskMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *NotifyTaskMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the NotifyTask entity.
// If the NotifyTask object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *NotifyTaskMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *NotifyTaskMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetStatus sets the "status" field.
func (m *NotifyTaskMutation) SetStatus(u uint8) {
	m.status = &u
	m.addstatus = nil
}

// Status returns the value of the "status" field in the mutation.
func (m *NotifyTaskMutation) Status() (r uint8, exists bool) {
	v := m.status
	if v == nil {
		return
	}
	return *v, true
}

// OldStatus returns the old "status" field's value of the NotifyTask entity.
// If the NotifyTask object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *NotifyTaskMutation) OldStatus(ctx context.Context) (v uint8, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatus: %w", err)
	}
	return oldValue.Status, nil
}

// AddStatus adds u to the "status" field.
func (m *NotifyTaskMutation) AddStatus(u int8) {
	if m.addstatus != nil {
		*m.addstatus += u
	} else {
		m.addstatus = &u
	}
}

// AddedStatus returns the value that was added to the "status" field in this mutation.
func (m *NotifyTaskMutation) AddedStatus() (r int8, exists bool) {
	v := m.addstatus
	if v == nil {
		return
	}
	return *v, true
}

// ClearStatus clears the value of the "status" field.
func (m *NotifyTaskMutation) ClearStatus() {
	m.status = nil
	m.addstatus = nil
	m.clearedFields[notifytask.FieldStatus] = struct{}{}
}

// StatusCleared returns if the "status" field was cleared in this mutation.
func (m *NotifyTaskMutation) StatusCleared() bool {
	_, ok := m.clearedFields[notifytask.FieldStatus]
	return ok
}

// ResetStatus resets all changes to the "status" field.
func (m *NotifyTaskMutation) ResetStatus() {
	m.status = nil
	m.addstatus = nil
	delete(m.clearedFields, notifytask.FieldStatus)
}

// SetDeletedAt sets the "deleted_at" field.
func (m *NotifyTaskMutation) SetDeletedAt(t time.Time) {
	m.deleted_at = &t
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *NotifyTaskMutation) DeletedAt() (r time.Time, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the NotifyTask entity.
// If the NotifyTask object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *NotifyTaskMutation) OldDeletedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// ClearDeletedAt clears the value of the "deleted_at" field.
func (m *NotifyTaskMutation) ClearDeletedAt() {
	m.deleted_at = nil
	m.clearedFields[notifytask.FieldDeletedAt] = struct{}{}
}

// DeletedAtCleared returns if the "deleted_at" field was cleared in this mutation.
func (m *NotifyTaskMutation) DeletedAtCleared() bool {
	_, ok := m.clearedFields[notifytask.FieldDeletedAt]
	return ok
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *NotifyTaskMutation) ResetDeletedAt() {
	m.deleted_at = nil
	delete(m.clearedFields, notifytask.FieldDeletedAt)
}

// SetAppID sets the "app_id" field.
func (m *NotifyTaskMutation) SetAppID(u uint64) {
	m.app_id = &u
	m.addapp_id = nil
}

// AppID returns the value of the "app_id" field in the mutation.
func (m *NotifyTaskMutation) AppID() (r uint64, exists bool) {
	v := m.app_id
	if v == nil {
		return
	}
	return *v, true
}

// OldAppID returns the old "app_id" field's value of the NotifyTask entity.
// If the NotifyTask object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *NotifyTaskMutation) OldAppID(ctx context.Context) (v uint64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAppID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAppID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAppID: %w", err)
	}
	return oldValue.AppID, nil
}

// AddAppID adds u to the "app_id" field.
func (m *NotifyTaskMutation) AddAppID(u int64) {
	if m.addapp_id != nil {
		*m.addapp_id += u
	} else {
		m.addapp_id = &u
	}
}

// AddedAppID returns the value that was added to the "app_id" field in this mutation.
func (m *NotifyTaskMutation) AddedAppID() (r int64, exists bool) {
	v := m.addapp_id
	if v == nil {
		return
	}
	return *v, true
}

// ResetAppID resets all changes to the "app_id" field.
func (m *NotifyTaskMutation) ResetAppID() {
	m.app_id = nil
	m.addapp_id = nil
}

// SetType sets the "type" field.
func (m *NotifyTaskMutation) SetType(i int) {
	m._type = &i
	m.add_type = nil
}

// GetType returns the value of the "type" field in the mutation.
func (m *NotifyTaskMutation) GetType() (r int, exists bool) {
	v := m._type
	if v == nil {
		return
	}
	return *v, true
}

// OldType returns the old "type" field's value of the NotifyTask entity.
// If the NotifyTask object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *NotifyTaskMutation) OldType(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldType: %w", err)
	}
	return oldValue.Type, nil
}

// AddType adds i to the "type" field.
func (m *NotifyTaskMutation) AddType(i int) {
	if m.add_type != nil {
		*m.add_type += i
	} else {
		m.add_type = &i
	}
}

// AddedType returns the value that was added to the "type" field in this mutation.
func (m *NotifyTaskMutation) AddedType() (r int, exists bool) {
	v := m.add_type
	if v == nil {
		return
	}
	return *v, true
}

// ResetType resets all changes to the "type" field.
func (m *NotifyTaskMutation) ResetType() {
	m._type = nil
	m.add_type = nil
}

// SetDataID sets the "data_id" field.
func (m *NotifyTaskMutation) SetDataID(u uint64) {
	m.data_id = &u
	m.adddata_id = nil
}

// DataID returns the value of the "data_id" field in the mutation.
func (m *NotifyTaskMutation) DataID() (r uint64, exists bool) {
	v := m.data_id
	if v == nil {
		return
	}
	return *v, true
}

// OldDataID returns the old "data_id" field's value of the NotifyTask entity.
// If the NotifyTask object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *NotifyTaskMutation) OldDataID(ctx context.Context) (v uint64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDataID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDataID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDataID: %w", err)
	}
	return oldValue.DataID, nil
}

// AddDataID adds u to the "data_id" field.
func (m *NotifyTaskMutation) AddDataID(u int64) {
	if m.adddata_id != nil {
		*m.adddata_id += u
	} else {
		m.adddata_id = &u
	}
}

// AddedDataID returns the value that was added to the "data_id" field in this mutation.
func (m *NotifyTaskMutation) AddedDataID() (r int64, exists bool) {
	v := m.adddata_id
	if v == nil {
		return
	}
	return *v, true
}

// ResetDataID resets all changes to the "data_id" field.
func (m *NotifyTaskMutation) ResetDataID() {
	m.data_id = nil
	m.adddata_id = nil
}

// SetMerchantOrderID sets the "merchant_order_id" field.
func (m *NotifyTaskMutation) SetMerchantOrderID(s string) {
	m.merchant_order_id = &s
}

// MerchantOrderID returns the value of the "merchant_order_id" field in the mutation.
func (m *NotifyTaskMutation) MerchantOrderID() (r string, exists bool) {
	v := m.merchant_order_id
	if v == nil {
		return
	}
	return *v, true
}

// OldMerchantOrderID returns the old "merchant_order_id" field's value of the NotifyTask entity.
// If the NotifyTask object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *NotifyTaskMutation) OldMerchantOrderID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMerchantOrderID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMerchantOrderID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMerchantOrderID: %w", err)
	}
	return oldValue.MerchantOrderID, nil
}

// ResetMerchantOrderID resets all changes to the "merchant_order_id" field.
func (m *NotifyTaskMutation) ResetMerchantOrderID() {
	m.merchant_order_id = nil
}

// SetNextNotifyTime sets the "next_notify_time" field.
func (m *NotifyTaskMutation) SetNextNotifyTime(t time.Time) {
	m.next_notify_time = &t
}

// NextNotifyTime returns the value of the "next_notify_time" field in the mutation.
func (m *NotifyTaskMutation) NextNotifyTime() (r time.Time, exists bool) {
	v := m.next_notify_time
	if v == nil {
		return
	}
	return *v, true
}

// OldNextNotifyTime returns the old "next_notify_time" field's value of the NotifyTask entity.
// If the NotifyTask object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *NotifyTaskMutation) OldNextNotifyTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldNextNotifyTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldNextNotifyTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldNextNotifyTime: %w", err)
	}
	return oldValue.NextNotifyTime, nil
}

// ResetNextNotifyTime resets all changes to the "next_notify_time" field.
func (m *NotifyTaskMutation) ResetNextNotifyTime() {
	m.next_notify_time = nil
}

// SetLastExecuteTime sets the "last_execute_time" field.
func (m *NotifyTaskMutation) SetLastExecuteTime(t time.Time) {
	m.last_execute_time = &t
}

// LastExecuteTime returns the value of the "last_execute_time" field in the mutation.
func (m *NotifyTaskMutation) LastExecuteTime() (r time.Time, exists bool) {
	v := m.last_execute_time
	if v == nil {
		return
	}
	return *v, true
}

// OldLastExecuteTime returns the old "last_execute_time" field's value of the NotifyTask entity.
// If the NotifyTask object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *NotifyTaskMutation) OldLastExecuteTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLastExecuteTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLastExecuteTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLastExecuteTime: %w", err)
	}
	return oldValue.LastExecuteTime, nil
}

// ResetLastExecuteTime resets all changes to the "last_execute_time" field.
func (m *NotifyTaskMutation) ResetLastExecuteTime() {
	m.last_execute_time = nil
}

// SetNotifyTimes sets the "notify_times" field.
func (m *NotifyTaskMutation) SetNotifyTimes(i int8) {
	m.notify_times = &i
	m.addnotify_times = nil
}

// NotifyTimes returns the value of the "notify_times" field in the mutation.
func (m *NotifyTaskMutation) NotifyTimes() (r int8, exists bool) {
	v := m.notify_times
	if v == nil {
		return
	}
	return *v, true
}

// OldNotifyTimes returns the old "notify_times" field's value of the NotifyTask entity.
// If the NotifyTask object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *NotifyTaskMutation) OldNotifyTimes(ctx context.Context) (v int8, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldNotifyTimes is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldNotifyTimes requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldNotifyTimes: %w", err)
	}
	return oldValue.NotifyTimes, nil
}

// AddNotifyTimes adds i to the "notify_times" field.
func (m *NotifyTaskMutation) AddNotifyTimes(i int8) {
	if m.addnotify_times != nil {
		*m.addnotify_times += i
	} else {
		m.addnotify_times = &i
	}
}

// AddedNotifyTimes returns the value that was added to the "notify_times" field in this mutation.
func (m *NotifyTaskMutation) AddedNotifyTimes() (r int8, exists bool) {
	v := m.addnotify_times
	if v == nil {
		return
	}
	return *v, true
}

// ResetNotifyTimes resets all changes to the "notify_times" field.
func (m *NotifyTaskMutation) ResetNotifyTimes() {
	m.notify_times = nil
	m.addnotify_times = nil
}

// SetMaxNotifyTimes sets the "max_notify_times" field.
func (m *NotifyTaskMutation) SetMaxNotifyTimes(i int8) {
	m.max_notify_times = &i
	m.addmax_notify_times = nil
}

// MaxNotifyTimes returns the value of the "max_notify_times" field in the mutation.
func (m *NotifyTaskMutation) MaxNotifyTimes() (r int8, exists bool) {
	v := m.max_notify_times
	if v == nil {
		return
	}
	return *v, true
}

// OldMaxNotifyTimes returns the old "max_notify_times" field's value of the NotifyTask entity.
// If the NotifyTask object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *NotifyTaskMutation) OldMaxNotifyTimes(ctx context.Context) (v int8, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMaxNotifyTimes is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMaxNotifyTimes requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMaxNotifyTimes: %w", err)
	}
	return oldValue.MaxNotifyTimes, nil
}

// AddMaxNotifyTimes adds i to the "max_notify_times" field.
func (m *NotifyTaskMutation) AddMaxNotifyTimes(i int8) {
	if m.addmax_notify_times != nil {
		*m.addmax_notify_times += i
	} else {
		m.addmax_notify_times = &i
	}
}

// AddedMaxNotifyTimes returns the value that was added to the "max_notify_times" field in this mutation.
func (m *NotifyTaskMutation) AddedMaxNotifyTimes() (r int8, exists bool) {
	v := m.addmax_notify_times
	if v == nil {
		return
	}
	return *v, true
}

// ResetMaxNotifyTimes resets all changes to the "max_notify_times" field.
func (m *NotifyTaskMutation) ResetMaxNotifyTimes() {
	m.max_notify_times = nil
	m.addmax_notify_times = nil
}

// SetNotifyURL sets the "notify_url" field.
func (m *NotifyTaskMutation) SetNotifyURL(s string) {
	m.notify_url = &s
}

// NotifyURL returns the value of the "notify_url" field in the mutation.
func (m *NotifyTaskMutation) NotifyURL() (r string, exists bool) {
	v := m.notify_url
	if v == nil {
		return
	}
	return *v, true
}

// OldNotifyURL returns the old "notify_url" field's value of the NotifyTask entity.
// If the NotifyTask object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *NotifyTaskMutation) OldNotifyURL(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldNotifyURL is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldNotifyURL requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldNotifyURL: %w", err)
	}
	return oldValue.NotifyURL, nil
}

// ResetNotifyURL resets all changes to the "notify_url" field.
func (m *NotifyTaskMutation) ResetNotifyURL() {
	m.notify_url = nil
}

// Where appends a list predicates to the NotifyTaskMutation builder.
func (m *NotifyTaskMutation) Where(ps ...predicate.NotifyTask) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the NotifyTaskMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *NotifyTaskMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.NotifyTask, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *NotifyTaskMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *NotifyTaskMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (NotifyTask).
func (m *NotifyTaskMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *NotifyTaskMutation) Fields() []string {
	fields := make([]string, 0, 13)
	if m.created_at != nil {
		fields = append(fields, notifytask.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, notifytask.FieldUpdatedAt)
	}
	if m.status != nil {
		fields = append(fields, notifytask.FieldStatus)
	}
	if m.deleted_at != nil {
		fields = append(fields, notifytask.FieldDeletedAt)
	}
	if m.app_id != nil {
		fields = append(fields, notifytask.FieldAppID)
	}
	if m._type != nil {
		fields = append(fields, notifytask.FieldType)
	}
	if m.data_id != nil {
		fields = append(fields, notifytask.FieldDataID)
	}
	if m.merchant_order_id != nil {
		fields = append(fields, notifytask.FieldMerchantOrderID)
	}
	if m.next_notify_time != nil {
		fields = append(fields, notifytask.FieldNextNotifyTime)
	}
	if m.last_execute_time != nil {
		fields = append(fields, notifytask.FieldLastExecuteTime)
	}
	if m.notify_times != nil {
		fields = append(fields, notifytask.FieldNotifyTimes)
	}
	if m.max_notify_times != nil {
		fields = append(fields, notifytask.FieldMaxNotifyTimes)
	}
	if m.notify_url != nil {
		fields = append(fields, notifytask.FieldNotifyURL)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *NotifyTaskMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case notifytask.FieldCreatedAt:
		return m.CreatedAt()
	case notifytask.FieldUpdatedAt:
		return m.UpdatedAt()
	case notifytask.FieldStatus:
		return m.Status()
	case notifytask.FieldDeletedAt:
		return m.DeletedAt()
	case notifytask.FieldAppID:
		return m.AppID()
	case notifytask.FieldType:
		return m.GetType()
	case notifytask.FieldDataID:
		return m.DataID()
	case notifytask.FieldMerchantOrderID:
		return m.MerchantOrderID()
	case notifytask.FieldNextNotifyTime:
		return m.NextNotifyTime()
	case notifytask.FieldLastExecuteTime:
		return m.LastExecuteTime()
	case notifytask.FieldNotifyTimes:
		return m.NotifyTimes()
	case notifytask.FieldMaxNotifyTimes:
		return m.MaxNotifyTimes()
	case notifytask.FieldNotifyURL:
		return m.NotifyURL()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *NotifyTaskMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case notifytask.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case notifytask.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case notifytask.FieldStatus:
		return m.OldStatus(ctx)
	case notifytask.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case notifytask.FieldAppID:
		return m.OldAppID(ctx)
	case notifytask.FieldType:
		return m.OldType(ctx)
	case notifytask.FieldDataID:
		return m.OldDataID(ctx)
	case notifytask.FieldMerchantOrderID:
		return m.OldMerchantOrderID(ctx)
	case notifytask.FieldNextNotifyTime:
		return m.OldNextNotifyTime(ctx)
	case notifytask.FieldLastExecuteTime:
		return m.OldLastExecuteTime(ctx)
	case notifytask.FieldNotifyTimes:
		return m.OldNotifyTimes(ctx)
	case notifytask.FieldMaxNotifyTimes:
		return m.OldMaxNotifyTimes(ctx)
	case notifytask.FieldNotifyURL:
		return m.OldNotifyURL(ctx)
	}
	return nil, fmt.Errorf("unknown NotifyTask field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *NotifyTaskMutation) SetField(name string, value ent.Value) error {
	switch name {
	case notifytask.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case notifytask.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case notifytask.FieldStatus:
		v, ok := value.(uint8)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatus(v)
		return nil
	case notifytask.FieldDeletedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case notifytask.FieldAppID:
		v, ok := value.(uint64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAppID(v)
		return nil
	case notifytask.FieldType:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetType(v)
		return nil
	case notifytask.FieldDataID:
		v, ok := value.(uint64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDataID(v)
		return nil
	case notifytask.FieldMerchantOrderID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMerchantOrderID(v)
		return nil
	case notifytask.FieldNextNotifyTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetNextNotifyTime(v)
		return nil
	case notifytask.FieldLastExecuteTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLastExecuteTime(v)
		return nil
	case notifytask.FieldNotifyTimes:
		v, ok := value.(int8)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetNotifyTimes(v)
		return nil
	case notifytask.FieldMaxNotifyTimes:
		v, ok := value.(int8)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMaxNotifyTimes(v)
		return nil
	case notifytask.FieldNotifyURL:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetNotifyURL(v)
		return nil
	}
	return fmt.Errorf("unknown NotifyTask field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *NotifyTaskMutation) AddedFields() []string {
	var fields []string
	if m.addstatus != nil {
		fields = append(fields, notifytask.FieldStatus)
	}
	if m.addapp_id != nil {
		fields = append(fields, notifytask.FieldAppID)
	}
	if m.add_type != nil {
		fields = append(fields, notifytask.FieldType)
	}
	if m.adddata_id != nil {
		fields = append(fields, notifytask.FieldDataID)
	}
	if m.addnotify_times != nil {
		fields = append(fields, notifytask.FieldNotifyTimes)
	}
	if m.addmax_notify_times != nil {
		fields = append(fields, notifytask.FieldMaxNotifyTimes)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *NotifyTaskMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case notifytask.FieldStatus:
		return m.AddedStatus()
	case notifytask.FieldAppID:
		return m.AddedAppID()
	case notifytask.FieldType:
		return m.AddedType()
	case notifytask.FieldDataID:
		return m.AddedDataID()
	case notifytask.FieldNotifyTimes:
		return m.AddedNotifyTimes()
	case notifytask.FieldMaxNotifyTimes:
		return m.AddedMaxNotifyTimes()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *NotifyTaskMutation) AddField(name string, value ent.Value) error {
	switch name {
	case notifytask.FieldStatus:
		v, ok := value.(int8)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddStatus(v)
		return nil
	case notifytask.FieldAppID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddAppID(v)
		return nil
	case notifytask.FieldType:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddType(v)
		return nil
	case notifytask.FieldDataID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddDataID(v)
		return nil
	case notifytask.FieldNotifyTimes:
		v, ok := value.(int8)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddNotifyTimes(v)
		return nil
	case notifytask.FieldMaxNotifyTimes:
		v, ok := value.(int8)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddMaxNotifyTimes(v)
		return nil
	}
	return fmt.Errorf("unknown NotifyTask numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *NotifyTaskMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(notifytask.FieldStatus) {
		fields = append(fields, notifytask.FieldStatus)
	}
	if m.FieldCleared(notifytask.FieldDeletedAt) {
		fields = append(fields, notifytask.FieldDeletedAt)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *NotifyTaskMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *NotifyTaskMutation) ClearField(name string) error {
	switch name {
	case notifytask.FieldStatus:
		m.ClearStatus()
		return nil
	case notifytask.FieldDeletedAt:
		m.ClearDeletedAt()
		return nil
	}
	return fmt.Errorf("unknown NotifyTask nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *NotifyTaskMutation) ResetField(name string) error {
	switch name {
	case notifytask.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case notifytask.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case notifytask.FieldStatus:
		m.ResetStatus()
		return nil
	case notifytask.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case notifytask.FieldAppID:
		m.ResetAppID()
		return nil
	case notifytask.FieldType:
		m.ResetType()
		return nil
	case notifytask.FieldDataID:
		m.ResetDataID()
		return nil
	case notifytask.FieldMerchantOrderID:
		m.ResetMerchantOrderID()
		return nil
	case notifytask.FieldNextNotifyTime:
		m.ResetNextNotifyTime()
		return nil
	case notifytask.FieldLastExecuteTime:
		m.ResetLastExecuteTime()
		return nil
	case notifytask.FieldNotifyTimes:
		m.ResetNotifyTimes()
		return nil
	case notifytask.FieldMaxNotifyTimes:
		m.ResetMaxNotifyTimes()
		return nil
	case notifytask.FieldNotifyURL:
		m.ResetNotifyURL()
		return nil
	}
	return fmt.Errorf("unknown NotifyTask field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *NotifyTaskMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *NotifyTaskMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *NotifyTaskMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *NotifyTaskMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *NotifyTaskMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *NotifyTaskMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *NotifyTaskMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown NotifyTask unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *NotifyTaskMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown NotifyTask edge %s", name)
}

// OrderMutation represents an operation that mutates the Order nodes in the graph.
type OrderMutation struct {
	config
	op                   Op
	typ                  string
	id                   *uint64
	created_at           *time.Time
	updated_at           *time.Time
	status               *uint8
	addstatus            *int8
	deleted_at           *time.Time
	app_id               *uint64
	addapp_id            *int64
	channel_id           *uint64
	addchannel_id        *int64
	channel_code         *string
	merchant_order_id    *string
	subject              *string
	body                 *string
	notify_url           *string
	price                *int32
	addprice             *int32
	channel_fee_rate     *float64
	addchannel_fee_rate  *float64
	channel_fee_price    *int32
	addchannel_fee_price *int32
	user_ip              *string
	expire_time          *time.Time
	success_time         *time.Time
	notify_time          *time.Time
	extension_id         *uint64
	addextension_id      *int64
	no                   *string
	refund_price         *int32
	addrefund_price      *int32
	channel_user_id      *string
	channel_order_no     *string
	clearedFields        map[string]struct{}
	done                 bool
	oldValue             func(context.Context) (*Order, error)
	predicates           []predicate.Order
}

var _ ent.Mutation = (*OrderMutation)(nil)

// orderOption allows management of the mutation configuration using functional options.
type orderOption func(*OrderMutation)

// newOrderMutation creates new mutation for the Order entity.
func newOrderMutation(c config, op Op, opts ...orderOption) *OrderMutation {
	m := &OrderMutation{
		config:        c,
		op:            op,
		typ:           TypeOrder,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withOrderID sets the ID field of the mutation.
func withOrderID(id uint64) orderOption {
	return func(m *OrderMutation) {
		var (
			err   error
			once  sync.Once
			value *Order
		)
		m.oldValue = func(ctx context.Context) (*Order, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Order.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withOrder sets the old Order of the mutation.
func withOrder(node *Order) orderOption {
	return func(m *OrderMutation) {
		m.oldValue = func(context.Context) (*Order, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m OrderMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m OrderMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Order entities.
func (m *OrderMutation) SetID(id uint64) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *OrderMutation) ID() (id uint64, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *OrderMutation) IDs(ctx context.Context) ([]uint64, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uint64{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Order.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *OrderMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *OrderMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Order entity.
// If the Order object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrderMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *OrderMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *OrderMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *OrderMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Order entity.
// If the Order object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrderMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *OrderMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetStatus sets the "status" field.
func (m *OrderMutation) SetStatus(u uint8) {
	m.status = &u
	m.addstatus = nil
}

// Status returns the value of the "status" field in the mutation.
func (m *OrderMutation) Status() (r uint8, exists bool) {
	v := m.status
	if v == nil {
		return
	}
	return *v, true
}

// OldStatus returns the old "status" field's value of the Order entity.
// If the Order object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrderMutation) OldStatus(ctx context.Context) (v uint8, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatus: %w", err)
	}
	return oldValue.Status, nil
}

// AddStatus adds u to the "status" field.
func (m *OrderMutation) AddStatus(u int8) {
	if m.addstatus != nil {
		*m.addstatus += u
	} else {
		m.addstatus = &u
	}
}

// AddedStatus returns the value that was added to the "status" field in this mutation.
func (m *OrderMutation) AddedStatus() (r int8, exists bool) {
	v := m.addstatus
	if v == nil {
		return
	}
	return *v, true
}

// ClearStatus clears the value of the "status" field.
func (m *OrderMutation) ClearStatus() {
	m.status = nil
	m.addstatus = nil
	m.clearedFields[order.FieldStatus] = struct{}{}
}

// StatusCleared returns if the "status" field was cleared in this mutation.
func (m *OrderMutation) StatusCleared() bool {
	_, ok := m.clearedFields[order.FieldStatus]
	return ok
}

// ResetStatus resets all changes to the "status" field.
func (m *OrderMutation) ResetStatus() {
	m.status = nil
	m.addstatus = nil
	delete(m.clearedFields, order.FieldStatus)
}

// SetDeletedAt sets the "deleted_at" field.
func (m *OrderMutation) SetDeletedAt(t time.Time) {
	m.deleted_at = &t
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *OrderMutation) DeletedAt() (r time.Time, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the Order entity.
// If the Order object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrderMutation) OldDeletedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// ClearDeletedAt clears the value of the "deleted_at" field.
func (m *OrderMutation) ClearDeletedAt() {
	m.deleted_at = nil
	m.clearedFields[order.FieldDeletedAt] = struct{}{}
}

// DeletedAtCleared returns if the "deleted_at" field was cleared in this mutation.
func (m *OrderMutation) DeletedAtCleared() bool {
	_, ok := m.clearedFields[order.FieldDeletedAt]
	return ok
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *OrderMutation) ResetDeletedAt() {
	m.deleted_at = nil
	delete(m.clearedFields, order.FieldDeletedAt)
}

// SetAppID sets the "app_id" field.
func (m *OrderMutation) SetAppID(u uint64) {
	m.app_id = &u
	m.addapp_id = nil
}

// AppID returns the value of the "app_id" field in the mutation.
func (m *OrderMutation) AppID() (r uint64, exists bool) {
	v := m.app_id
	if v == nil {
		return
	}
	return *v, true
}

// OldAppID returns the old "app_id" field's value of the Order entity.
// If the Order object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrderMutation) OldAppID(ctx context.Context) (v uint64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAppID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAppID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAppID: %w", err)
	}
	return oldValue.AppID, nil
}

// AddAppID adds u to the "app_id" field.
func (m *OrderMutation) AddAppID(u int64) {
	if m.addapp_id != nil {
		*m.addapp_id += u
	} else {
		m.addapp_id = &u
	}
}

// AddedAppID returns the value that was added to the "app_id" field in this mutation.
func (m *OrderMutation) AddedAppID() (r int64, exists bool) {
	v := m.addapp_id
	if v == nil {
		return
	}
	return *v, true
}

// ResetAppID resets all changes to the "app_id" field.
func (m *OrderMutation) ResetAppID() {
	m.app_id = nil
	m.addapp_id = nil
}

// SetChannelID sets the "channel_id" field.
func (m *OrderMutation) SetChannelID(u uint64) {
	m.channel_id = &u
	m.addchannel_id = nil
}

// ChannelID returns the value of the "channel_id" field in the mutation.
func (m *OrderMutation) ChannelID() (r uint64, exists bool) {
	v := m.channel_id
	if v == nil {
		return
	}
	return *v, true
}

// OldChannelID returns the old "channel_id" field's value of the Order entity.
// If the Order object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrderMutation) OldChannelID(ctx context.Context) (v uint64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldChannelID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldChannelID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldChannelID: %w", err)
	}
	return oldValue.ChannelID, nil
}

// AddChannelID adds u to the "channel_id" field.
func (m *OrderMutation) AddChannelID(u int64) {
	if m.addchannel_id != nil {
		*m.addchannel_id += u
	} else {
		m.addchannel_id = &u
	}
}

// AddedChannelID returns the value that was added to the "channel_id" field in this mutation.
func (m *OrderMutation) AddedChannelID() (r int64, exists bool) {
	v := m.addchannel_id
	if v == nil {
		return
	}
	return *v, true
}

// ClearChannelID clears the value of the "channel_id" field.
func (m *OrderMutation) ClearChannelID() {
	m.channel_id = nil
	m.addchannel_id = nil
	m.clearedFields[order.FieldChannelID] = struct{}{}
}

// ChannelIDCleared returns if the "channel_id" field was cleared in this mutation.
func (m *OrderMutation) ChannelIDCleared() bool {
	_, ok := m.clearedFields[order.FieldChannelID]
	return ok
}

// ResetChannelID resets all changes to the "channel_id" field.
func (m *OrderMutation) ResetChannelID() {
	m.channel_id = nil
	m.addchannel_id = nil
	delete(m.clearedFields, order.FieldChannelID)
}

// SetChannelCode sets the "channel_code" field.
func (m *OrderMutation) SetChannelCode(s string) {
	m.channel_code = &s
}

// ChannelCode returns the value of the "channel_code" field in the mutation.
func (m *OrderMutation) ChannelCode() (r string, exists bool) {
	v := m.channel_code
	if v == nil {
		return
	}
	return *v, true
}

// OldChannelCode returns the old "channel_code" field's value of the Order entity.
// If the Order object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrderMutation) OldChannelCode(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldChannelCode is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldChannelCode requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldChannelCode: %w", err)
	}
	return oldValue.ChannelCode, nil
}

// ClearChannelCode clears the value of the "channel_code" field.
func (m *OrderMutation) ClearChannelCode() {
	m.channel_code = nil
	m.clearedFields[order.FieldChannelCode] = struct{}{}
}

// ChannelCodeCleared returns if the "channel_code" field was cleared in this mutation.
func (m *OrderMutation) ChannelCodeCleared() bool {
	_, ok := m.clearedFields[order.FieldChannelCode]
	return ok
}

// ResetChannelCode resets all changes to the "channel_code" field.
func (m *OrderMutation) ResetChannelCode() {
	m.channel_code = nil
	delete(m.clearedFields, order.FieldChannelCode)
}

// SetMerchantOrderID sets the "merchant_order_id" field.
func (m *OrderMutation) SetMerchantOrderID(s string) {
	m.merchant_order_id = &s
}

// MerchantOrderID returns the value of the "merchant_order_id" field in the mutation.
func (m *OrderMutation) MerchantOrderID() (r string, exists bool) {
	v := m.merchant_order_id
	if v == nil {
		return
	}
	return *v, true
}

// OldMerchantOrderID returns the old "merchant_order_id" field's value of the Order entity.
// If the Order object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrderMutation) OldMerchantOrderID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMerchantOrderID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMerchantOrderID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMerchantOrderID: %w", err)
	}
	return oldValue.MerchantOrderID, nil
}

// ResetMerchantOrderID resets all changes to the "merchant_order_id" field.
func (m *OrderMutation) ResetMerchantOrderID() {
	m.merchant_order_id = nil
}

// SetSubject sets the "subject" field.
func (m *OrderMutation) SetSubject(s string) {
	m.subject = &s
}

// Subject returns the value of the "subject" field in the mutation.
func (m *OrderMutation) Subject() (r string, exists bool) {
	v := m.subject
	if v == nil {
		return
	}
	return *v, true
}

// OldSubject returns the old "subject" field's value of the Order entity.
// If the Order object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrderMutation) OldSubject(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSubject is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSubject requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSubject: %w", err)
	}
	return oldValue.Subject, nil
}

// ResetSubject resets all changes to the "subject" field.
func (m *OrderMutation) ResetSubject() {
	m.subject = nil
}

// SetBody sets the "body" field.
func (m *OrderMutation) SetBody(s string) {
	m.body = &s
}

// Body returns the value of the "body" field in the mutation.
func (m *OrderMutation) Body() (r string, exists bool) {
	v := m.body
	if v == nil {
		return
	}
	return *v, true
}

// OldBody returns the old "body" field's value of the Order entity.
// If the Order object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrderMutation) OldBody(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldBody is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldBody requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldBody: %w", err)
	}
	return oldValue.Body, nil
}

// ResetBody resets all changes to the "body" field.
func (m *OrderMutation) ResetBody() {
	m.body = nil
}

// SetNotifyURL sets the "notify_url" field.
func (m *OrderMutation) SetNotifyURL(s string) {
	m.notify_url = &s
}

// NotifyURL returns the value of the "notify_url" field in the mutation.
func (m *OrderMutation) NotifyURL() (r string, exists bool) {
	v := m.notify_url
	if v == nil {
		return
	}
	return *v, true
}

// OldNotifyURL returns the old "notify_url" field's value of the Order entity.
// If the Order object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrderMutation) OldNotifyURL(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldNotifyURL is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldNotifyURL requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldNotifyURL: %w", err)
	}
	return oldValue.NotifyURL, nil
}

// ResetNotifyURL resets all changes to the "notify_url" field.
func (m *OrderMutation) ResetNotifyURL() {
	m.notify_url = nil
}

// SetPrice sets the "price" field.
func (m *OrderMutation) SetPrice(i int32) {
	m.price = &i
	m.addprice = nil
}

// Price returns the value of the "price" field in the mutation.
func (m *OrderMutation) Price() (r int32, exists bool) {
	v := m.price
	if v == nil {
		return
	}
	return *v, true
}

// OldPrice returns the old "price" field's value of the Order entity.
// If the Order object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrderMutation) OldPrice(ctx context.Context) (v int32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPrice is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPrice requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPrice: %w", err)
	}
	return oldValue.Price, nil
}

// AddPrice adds i to the "price" field.
func (m *OrderMutation) AddPrice(i int32) {
	if m.addprice != nil {
		*m.addprice += i
	} else {
		m.addprice = &i
	}
}

// AddedPrice returns the value that was added to the "price" field in this mutation.
func (m *OrderMutation) AddedPrice() (r int32, exists bool) {
	v := m.addprice
	if v == nil {
		return
	}
	return *v, true
}

// ResetPrice resets all changes to the "price" field.
func (m *OrderMutation) ResetPrice() {
	m.price = nil
	m.addprice = nil
}

// SetChannelFeeRate sets the "channel_fee_rate" field.
func (m *OrderMutation) SetChannelFeeRate(f float64) {
	m.channel_fee_rate = &f
	m.addchannel_fee_rate = nil
}

// ChannelFeeRate returns the value of the "channel_fee_rate" field in the mutation.
func (m *OrderMutation) ChannelFeeRate() (r float64, exists bool) {
	v := m.channel_fee_rate
	if v == nil {
		return
	}
	return *v, true
}

// OldChannelFeeRate returns the old "channel_fee_rate" field's value of the Order entity.
// If the Order object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrderMutation) OldChannelFeeRate(ctx context.Context) (v float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldChannelFeeRate is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldChannelFeeRate requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldChannelFeeRate: %w", err)
	}
	return oldValue.ChannelFeeRate, nil
}

// AddChannelFeeRate adds f to the "channel_fee_rate" field.
func (m *OrderMutation) AddChannelFeeRate(f float64) {
	if m.addchannel_fee_rate != nil {
		*m.addchannel_fee_rate += f
	} else {
		m.addchannel_fee_rate = &f
	}
}

// AddedChannelFeeRate returns the value that was added to the "channel_fee_rate" field in this mutation.
func (m *OrderMutation) AddedChannelFeeRate() (r float64, exists bool) {
	v := m.addchannel_fee_rate
	if v == nil {
		return
	}
	return *v, true
}

// ClearChannelFeeRate clears the value of the "channel_fee_rate" field.
func (m *OrderMutation) ClearChannelFeeRate() {
	m.channel_fee_rate = nil
	m.addchannel_fee_rate = nil
	m.clearedFields[order.FieldChannelFeeRate] = struct{}{}
}

// ChannelFeeRateCleared returns if the "channel_fee_rate" field was cleared in this mutation.
func (m *OrderMutation) ChannelFeeRateCleared() bool {
	_, ok := m.clearedFields[order.FieldChannelFeeRate]
	return ok
}

// ResetChannelFeeRate resets all changes to the "channel_fee_rate" field.
func (m *OrderMutation) ResetChannelFeeRate() {
	m.channel_fee_rate = nil
	m.addchannel_fee_rate = nil
	delete(m.clearedFields, order.FieldChannelFeeRate)
}

// SetChannelFeePrice sets the "channel_fee_price" field.
func (m *OrderMutation) SetChannelFeePrice(i int32) {
	m.channel_fee_price = &i
	m.addchannel_fee_price = nil
}

// ChannelFeePrice returns the value of the "channel_fee_price" field in the mutation.
func (m *OrderMutation) ChannelFeePrice() (r int32, exists bool) {
	v := m.channel_fee_price
	if v == nil {
		return
	}
	return *v, true
}

// OldChannelFeePrice returns the old "channel_fee_price" field's value of the Order entity.
// If the Order object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrderMutation) OldChannelFeePrice(ctx context.Context) (v int32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldChannelFeePrice is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldChannelFeePrice requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldChannelFeePrice: %w", err)
	}
	return oldValue.ChannelFeePrice, nil
}

// AddChannelFeePrice adds i to the "channel_fee_price" field.
func (m *OrderMutation) AddChannelFeePrice(i int32) {
	if m.addchannel_fee_price != nil {
		*m.addchannel_fee_price += i
	} else {
		m.addchannel_fee_price = &i
	}
}

// AddedChannelFeePrice returns the value that was added to the "channel_fee_price" field in this mutation.
func (m *OrderMutation) AddedChannelFeePrice() (r int32, exists bool) {
	v := m.addchannel_fee_price
	if v == nil {
		return
	}
	return *v, true
}

// ClearChannelFeePrice clears the value of the "channel_fee_price" field.
func (m *OrderMutation) ClearChannelFeePrice() {
	m.channel_fee_price = nil
	m.addchannel_fee_price = nil
	m.clearedFields[order.FieldChannelFeePrice] = struct{}{}
}

// ChannelFeePriceCleared returns if the "channel_fee_price" field was cleared in this mutation.
func (m *OrderMutation) ChannelFeePriceCleared() bool {
	_, ok := m.clearedFields[order.FieldChannelFeePrice]
	return ok
}

// ResetChannelFeePrice resets all changes to the "channel_fee_price" field.
func (m *OrderMutation) ResetChannelFeePrice() {
	m.channel_fee_price = nil
	m.addchannel_fee_price = nil
	delete(m.clearedFields, order.FieldChannelFeePrice)
}

// SetUserIP sets the "user_ip" field.
func (m *OrderMutation) SetUserIP(s string) {
	m.user_ip = &s
}

// UserIP returns the value of the "user_ip" field in the mutation.
func (m *OrderMutation) UserIP() (r string, exists bool) {
	v := m.user_ip
	if v == nil {
		return
	}
	return *v, true
}

// OldUserIP returns the old "user_ip" field's value of the Order entity.
// If the Order object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrderMutation) OldUserIP(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUserIP is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUserIP requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUserIP: %w", err)
	}
	return oldValue.UserIP, nil
}

// ResetUserIP resets all changes to the "user_ip" field.
func (m *OrderMutation) ResetUserIP() {
	m.user_ip = nil
}

// SetExpireTime sets the "expire_time" field.
func (m *OrderMutation) SetExpireTime(t time.Time) {
	m.expire_time = &t
}

// ExpireTime returns the value of the "expire_time" field in the mutation.
func (m *OrderMutation) ExpireTime() (r time.Time, exists bool) {
	v := m.expire_time
	if v == nil {
		return
	}
	return *v, true
}

// OldExpireTime returns the old "expire_time" field's value of the Order entity.
// If the Order object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrderMutation) OldExpireTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldExpireTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldExpireTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldExpireTime: %w", err)
	}
	return oldValue.ExpireTime, nil
}

// ResetExpireTime resets all changes to the "expire_time" field.
func (m *OrderMutation) ResetExpireTime() {
	m.expire_time = nil
}

// SetSuccessTime sets the "success_time" field.
func (m *OrderMutation) SetSuccessTime(t time.Time) {
	m.success_time = &t
}

// SuccessTime returns the value of the "success_time" field in the mutation.
func (m *OrderMutation) SuccessTime() (r time.Time, exists bool) {
	v := m.success_time
	if v == nil {
		return
	}
	return *v, true
}

// OldSuccessTime returns the old "success_time" field's value of the Order entity.
// If the Order object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrderMutation) OldSuccessTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSuccessTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSuccessTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSuccessTime: %w", err)
	}
	return oldValue.SuccessTime, nil
}

// ClearSuccessTime clears the value of the "success_time" field.
func (m *OrderMutation) ClearSuccessTime() {
	m.success_time = nil
	m.clearedFields[order.FieldSuccessTime] = struct{}{}
}

// SuccessTimeCleared returns if the "success_time" field was cleared in this mutation.
func (m *OrderMutation) SuccessTimeCleared() bool {
	_, ok := m.clearedFields[order.FieldSuccessTime]
	return ok
}

// ResetSuccessTime resets all changes to the "success_time" field.
func (m *OrderMutation) ResetSuccessTime() {
	m.success_time = nil
	delete(m.clearedFields, order.FieldSuccessTime)
}

// SetNotifyTime sets the "notify_time" field.
func (m *OrderMutation) SetNotifyTime(t time.Time) {
	m.notify_time = &t
}

// NotifyTime returns the value of the "notify_time" field in the mutation.
func (m *OrderMutation) NotifyTime() (r time.Time, exists bool) {
	v := m.notify_time
	if v == nil {
		return
	}
	return *v, true
}

// OldNotifyTime returns the old "notify_time" field's value of the Order entity.
// If the Order object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrderMutation) OldNotifyTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldNotifyTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldNotifyTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldNotifyTime: %w", err)
	}
	return oldValue.NotifyTime, nil
}

// ClearNotifyTime clears the value of the "notify_time" field.
func (m *OrderMutation) ClearNotifyTime() {
	m.notify_time = nil
	m.clearedFields[order.FieldNotifyTime] = struct{}{}
}

// NotifyTimeCleared returns if the "notify_time" field was cleared in this mutation.
func (m *OrderMutation) NotifyTimeCleared() bool {
	_, ok := m.clearedFields[order.FieldNotifyTime]
	return ok
}

// ResetNotifyTime resets all changes to the "notify_time" field.
func (m *OrderMutation) ResetNotifyTime() {
	m.notify_time = nil
	delete(m.clearedFields, order.FieldNotifyTime)
}

// SetExtensionID sets the "extension_id" field.
func (m *OrderMutation) SetExtensionID(u uint64) {
	m.extension_id = &u
	m.addextension_id = nil
}

// ExtensionID returns the value of the "extension_id" field in the mutation.
func (m *OrderMutation) ExtensionID() (r uint64, exists bool) {
	v := m.extension_id
	if v == nil {
		return
	}
	return *v, true
}

// OldExtensionID returns the old "extension_id" field's value of the Order entity.
// If the Order object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrderMutation) OldExtensionID(ctx context.Context) (v uint64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldExtensionID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldExtensionID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldExtensionID: %w", err)
	}
	return oldValue.ExtensionID, nil
}

// AddExtensionID adds u to the "extension_id" field.
func (m *OrderMutation) AddExtensionID(u int64) {
	if m.addextension_id != nil {
		*m.addextension_id += u
	} else {
		m.addextension_id = &u
	}
}

// AddedExtensionID returns the value that was added to the "extension_id" field in this mutation.
func (m *OrderMutation) AddedExtensionID() (r int64, exists bool) {
	v := m.addextension_id
	if v == nil {
		return
	}
	return *v, true
}

// ClearExtensionID clears the value of the "extension_id" field.
func (m *OrderMutation) ClearExtensionID() {
	m.extension_id = nil
	m.addextension_id = nil
	m.clearedFields[order.FieldExtensionID] = struct{}{}
}

// ExtensionIDCleared returns if the "extension_id" field was cleared in this mutation.
func (m *OrderMutation) ExtensionIDCleared() bool {
	_, ok := m.clearedFields[order.FieldExtensionID]
	return ok
}

// ResetExtensionID resets all changes to the "extension_id" field.
func (m *OrderMutation) ResetExtensionID() {
	m.extension_id = nil
	m.addextension_id = nil
	delete(m.clearedFields, order.FieldExtensionID)
}

// SetNo sets the "no" field.
func (m *OrderMutation) SetNo(s string) {
	m.no = &s
}

// No returns the value of the "no" field in the mutation.
func (m *OrderMutation) No() (r string, exists bool) {
	v := m.no
	if v == nil {
		return
	}
	return *v, true
}

// OldNo returns the old "no" field's value of the Order entity.
// If the Order object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrderMutation) OldNo(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldNo is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldNo requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldNo: %w", err)
	}
	return oldValue.No, nil
}

// ClearNo clears the value of the "no" field.
func (m *OrderMutation) ClearNo() {
	m.no = nil
	m.clearedFields[order.FieldNo] = struct{}{}
}

// NoCleared returns if the "no" field was cleared in this mutation.
func (m *OrderMutation) NoCleared() bool {
	_, ok := m.clearedFields[order.FieldNo]
	return ok
}

// ResetNo resets all changes to the "no" field.
func (m *OrderMutation) ResetNo() {
	m.no = nil
	delete(m.clearedFields, order.FieldNo)
}

// SetRefundPrice sets the "refund_price" field.
func (m *OrderMutation) SetRefundPrice(i int32) {
	m.refund_price = &i
	m.addrefund_price = nil
}

// RefundPrice returns the value of the "refund_price" field in the mutation.
func (m *OrderMutation) RefundPrice() (r int32, exists bool) {
	v := m.refund_price
	if v == nil {
		return
	}
	return *v, true
}

// OldRefundPrice returns the old "refund_price" field's value of the Order entity.
// If the Order object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrderMutation) OldRefundPrice(ctx context.Context) (v int32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRefundPrice is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRefundPrice requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRefundPrice: %w", err)
	}
	return oldValue.RefundPrice, nil
}

// AddRefundPrice adds i to the "refund_price" field.
func (m *OrderMutation) AddRefundPrice(i int32) {
	if m.addrefund_price != nil {
		*m.addrefund_price += i
	} else {
		m.addrefund_price = &i
	}
}

// AddedRefundPrice returns the value that was added to the "refund_price" field in this mutation.
func (m *OrderMutation) AddedRefundPrice() (r int32, exists bool) {
	v := m.addrefund_price
	if v == nil {
		return
	}
	return *v, true
}

// ResetRefundPrice resets all changes to the "refund_price" field.
func (m *OrderMutation) ResetRefundPrice() {
	m.refund_price = nil
	m.addrefund_price = nil
}

// SetChannelUserID sets the "channel_user_id" field.
func (m *OrderMutation) SetChannelUserID(s string) {
	m.channel_user_id = &s
}

// ChannelUserID returns the value of the "channel_user_id" field in the mutation.
func (m *OrderMutation) ChannelUserID() (r string, exists bool) {
	v := m.channel_user_id
	if v == nil {
		return
	}
	return *v, true
}

// OldChannelUserID returns the old "channel_user_id" field's value of the Order entity.
// If the Order object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrderMutation) OldChannelUserID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldChannelUserID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldChannelUserID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldChannelUserID: %w", err)
	}
	return oldValue.ChannelUserID, nil
}

// ClearChannelUserID clears the value of the "channel_user_id" field.
func (m *OrderMutation) ClearChannelUserID() {
	m.channel_user_id = nil
	m.clearedFields[order.FieldChannelUserID] = struct{}{}
}

// ChannelUserIDCleared returns if the "channel_user_id" field was cleared in this mutation.
func (m *OrderMutation) ChannelUserIDCleared() bool {
	_, ok := m.clearedFields[order.FieldChannelUserID]
	return ok
}

// ResetChannelUserID resets all changes to the "channel_user_id" field.
func (m *OrderMutation) ResetChannelUserID() {
	m.channel_user_id = nil
	delete(m.clearedFields, order.FieldChannelUserID)
}

// SetChannelOrderNo sets the "channel_order_no" field.
func (m *OrderMutation) SetChannelOrderNo(s string) {
	m.channel_order_no = &s
}

// ChannelOrderNo returns the value of the "channel_order_no" field in the mutation.
func (m *OrderMutation) ChannelOrderNo() (r string, exists bool) {
	v := m.channel_order_no
	if v == nil {
		return
	}
	return *v, true
}

// OldChannelOrderNo returns the old "channel_order_no" field's value of the Order entity.
// If the Order object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrderMutation) OldChannelOrderNo(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldChannelOrderNo is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldChannelOrderNo requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldChannelOrderNo: %w", err)
	}
	return oldValue.ChannelOrderNo, nil
}

// ClearChannelOrderNo clears the value of the "channel_order_no" field.
func (m *OrderMutation) ClearChannelOrderNo() {
	m.channel_order_no = nil
	m.clearedFields[order.FieldChannelOrderNo] = struct{}{}
}

// ChannelOrderNoCleared returns if the "channel_order_no" field was cleared in this mutation.
func (m *OrderMutation) ChannelOrderNoCleared() bool {
	_, ok := m.clearedFields[order.FieldChannelOrderNo]
	return ok
}

// ResetChannelOrderNo resets all changes to the "channel_order_no" field.
func (m *OrderMutation) ResetChannelOrderNo() {
	m.channel_order_no = nil
	delete(m.clearedFields, order.FieldChannelOrderNo)
}

// Where appends a list predicates to the OrderMutation builder.
func (m *OrderMutation) Where(ps ...predicate.Order) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the OrderMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *OrderMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Order, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *OrderMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *OrderMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Order).
func (m *OrderMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *OrderMutation) Fields() []string {
	fields := make([]string, 0, 23)
	if m.created_at != nil {
		fields = append(fields, order.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, order.FieldUpdatedAt)
	}
	if m.status != nil {
		fields = append(fields, order.FieldStatus)
	}
	if m.deleted_at != nil {
		fields = append(fields, order.FieldDeletedAt)
	}
	if m.app_id != nil {
		fields = append(fields, order.FieldAppID)
	}
	if m.channel_id != nil {
		fields = append(fields, order.FieldChannelID)
	}
	if m.channel_code != nil {
		fields = append(fields, order.FieldChannelCode)
	}
	if m.merchant_order_id != nil {
		fields = append(fields, order.FieldMerchantOrderID)
	}
	if m.subject != nil {
		fields = append(fields, order.FieldSubject)
	}
	if m.body != nil {
		fields = append(fields, order.FieldBody)
	}
	if m.notify_url != nil {
		fields = append(fields, order.FieldNotifyURL)
	}
	if m.price != nil {
		fields = append(fields, order.FieldPrice)
	}
	if m.channel_fee_rate != nil {
		fields = append(fields, order.FieldChannelFeeRate)
	}
	if m.channel_fee_price != nil {
		fields = append(fields, order.FieldChannelFeePrice)
	}
	if m.user_ip != nil {
		fields = append(fields, order.FieldUserIP)
	}
	if m.expire_time != nil {
		fields = append(fields, order.FieldExpireTime)
	}
	if m.success_time != nil {
		fields = append(fields, order.FieldSuccessTime)
	}
	if m.notify_time != nil {
		fields = append(fields, order.FieldNotifyTime)
	}
	if m.extension_id != nil {
		fields = append(fields, order.FieldExtensionID)
	}
	if m.no != nil {
		fields = append(fields, order.FieldNo)
	}
	if m.refund_price != nil {
		fields = append(fields, order.FieldRefundPrice)
	}
	if m.channel_user_id != nil {
		fields = append(fields, order.FieldChannelUserID)
	}
	if m.channel_order_no != nil {
		fields = append(fields, order.FieldChannelOrderNo)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *OrderMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case order.FieldCreatedAt:
		return m.CreatedAt()
	case order.FieldUpdatedAt:
		return m.UpdatedAt()
	case order.FieldStatus:
		return m.Status()
	case order.FieldDeletedAt:
		return m.DeletedAt()
	case order.FieldAppID:
		return m.AppID()
	case order.FieldChannelID:
		return m.ChannelID()
	case order.FieldChannelCode:
		return m.ChannelCode()
	case order.FieldMerchantOrderID:
		return m.MerchantOrderID()
	case order.FieldSubject:
		return m.Subject()
	case order.FieldBody:
		return m.Body()
	case order.FieldNotifyURL:
		return m.NotifyURL()
	case order.FieldPrice:
		return m.Price()
	case order.FieldChannelFeeRate:
		return m.ChannelFeeRate()
	case order.FieldChannelFeePrice:
		return m.ChannelFeePrice()
	case order.FieldUserIP:
		return m.UserIP()
	case order.FieldExpireTime:
		return m.ExpireTime()
	case order.FieldSuccessTime:
		return m.SuccessTime()
	case order.FieldNotifyTime:
		return m.NotifyTime()
	case order.FieldExtensionID:
		return m.ExtensionID()
	case order.FieldNo:
		return m.No()
	case order.FieldRefundPrice:
		return m.RefundPrice()
	case order.FieldChannelUserID:
		return m.ChannelUserID()
	case order.FieldChannelOrderNo:
		return m.ChannelOrderNo()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *OrderMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case order.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case order.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case order.FieldStatus:
		return m.OldStatus(ctx)
	case order.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case order.FieldAppID:
		return m.OldAppID(ctx)
	case order.FieldChannelID:
		return m.OldChannelID(ctx)
	case order.FieldChannelCode:
		return m.OldChannelCode(ctx)
	case order.FieldMerchantOrderID:
		return m.OldMerchantOrderID(ctx)
	case order.FieldSubject:
		return m.OldSubject(ctx)
	case order.FieldBody:
		return m.OldBody(ctx)
	case order.FieldNotifyURL:
		return m.OldNotifyURL(ctx)
	case order.FieldPrice:
		return m.OldPrice(ctx)
	case order.FieldChannelFeeRate:
		return m.OldChannelFeeRate(ctx)
	case order.FieldChannelFeePrice:
		return m.OldChannelFeePrice(ctx)
	case order.FieldUserIP:
		return m.OldUserIP(ctx)
	case order.FieldExpireTime:
		return m.OldExpireTime(ctx)
	case order.FieldSuccessTime:
		return m.OldSuccessTime(ctx)
	case order.FieldNotifyTime:
		return m.OldNotifyTime(ctx)
	case order.FieldExtensionID:
		return m.OldExtensionID(ctx)
	case order.FieldNo:
		return m.OldNo(ctx)
	case order.FieldRefundPrice:
		return m.OldRefundPrice(ctx)
	case order.FieldChannelUserID:
		return m.OldChannelUserID(ctx)
	case order.FieldChannelOrderNo:
		return m.OldChannelOrderNo(ctx)
	}
	return nil, fmt.Errorf("unknown Order field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *OrderMutation) SetField(name string, value ent.Value) error {
	switch name {
	case order.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case order.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case order.FieldStatus:
		v, ok := value.(uint8)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatus(v)
		return nil
	case order.FieldDeletedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case order.FieldAppID:
		v, ok := value.(uint64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAppID(v)
		return nil
	case order.FieldChannelID:
		v, ok := value.(uint64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetChannelID(v)
		return nil
	case order.FieldChannelCode:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetChannelCode(v)
		return nil
	case order.FieldMerchantOrderID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMerchantOrderID(v)
		return nil
	case order.FieldSubject:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSubject(v)
		return nil
	case order.FieldBody:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetBody(v)
		return nil
	case order.FieldNotifyURL:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetNotifyURL(v)
		return nil
	case order.FieldPrice:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPrice(v)
		return nil
	case order.FieldChannelFeeRate:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetChannelFeeRate(v)
		return nil
	case order.FieldChannelFeePrice:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetChannelFeePrice(v)
		return nil
	case order.FieldUserIP:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUserIP(v)
		return nil
	case order.FieldExpireTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetExpireTime(v)
		return nil
	case order.FieldSuccessTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSuccessTime(v)
		return nil
	case order.FieldNotifyTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetNotifyTime(v)
		return nil
	case order.FieldExtensionID:
		v, ok := value.(uint64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetExtensionID(v)
		return nil
	case order.FieldNo:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetNo(v)
		return nil
	case order.FieldRefundPrice:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRefundPrice(v)
		return nil
	case order.FieldChannelUserID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetChannelUserID(v)
		return nil
	case order.FieldChannelOrderNo:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetChannelOrderNo(v)
		return nil
	}
	return fmt.Errorf("unknown Order field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *OrderMutation) AddedFields() []string {
	var fields []string
	if m.addstatus != nil {
		fields = append(fields, order.FieldStatus)
	}
	if m.addapp_id != nil {
		fields = append(fields, order.FieldAppID)
	}
	if m.addchannel_id != nil {
		fields = append(fields, order.FieldChannelID)
	}
	if m.addprice != nil {
		fields = append(fields, order.FieldPrice)
	}
	if m.addchannel_fee_rate != nil {
		fields = append(fields, order.FieldChannelFeeRate)
	}
	if m.addchannel_fee_price != nil {
		fields = append(fields, order.FieldChannelFeePrice)
	}
	if m.addextension_id != nil {
		fields = append(fields, order.FieldExtensionID)
	}
	if m.addrefund_price != nil {
		fields = append(fields, order.FieldRefundPrice)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *OrderMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case order.FieldStatus:
		return m.AddedStatus()
	case order.FieldAppID:
		return m.AddedAppID()
	case order.FieldChannelID:
		return m.AddedChannelID()
	case order.FieldPrice:
		return m.AddedPrice()
	case order.FieldChannelFeeRate:
		return m.AddedChannelFeeRate()
	case order.FieldChannelFeePrice:
		return m.AddedChannelFeePrice()
	case order.FieldExtensionID:
		return m.AddedExtensionID()
	case order.FieldRefundPrice:
		return m.AddedRefundPrice()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *OrderMutation) AddField(name string, value ent.Value) error {
	switch name {
	case order.FieldStatus:
		v, ok := value.(int8)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddStatus(v)
		return nil
	case order.FieldAppID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddAppID(v)
		return nil
	case order.FieldChannelID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddChannelID(v)
		return nil
	case order.FieldPrice:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddPrice(v)
		return nil
	case order.FieldChannelFeeRate:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddChannelFeeRate(v)
		return nil
	case order.FieldChannelFeePrice:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddChannelFeePrice(v)
		return nil
	case order.FieldExtensionID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddExtensionID(v)
		return nil
	case order.FieldRefundPrice:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddRefundPrice(v)
		return nil
	}
	return fmt.Errorf("unknown Order numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *OrderMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(order.FieldStatus) {
		fields = append(fields, order.FieldStatus)
	}
	if m.FieldCleared(order.FieldDeletedAt) {
		fields = append(fields, order.FieldDeletedAt)
	}
	if m.FieldCleared(order.FieldChannelID) {
		fields = append(fields, order.FieldChannelID)
	}
	if m.FieldCleared(order.FieldChannelCode) {
		fields = append(fields, order.FieldChannelCode)
	}
	if m.FieldCleared(order.FieldChannelFeeRate) {
		fields = append(fields, order.FieldChannelFeeRate)
	}
	if m.FieldCleared(order.FieldChannelFeePrice) {
		fields = append(fields, order.FieldChannelFeePrice)
	}
	if m.FieldCleared(order.FieldSuccessTime) {
		fields = append(fields, order.FieldSuccessTime)
	}
	if m.FieldCleared(order.FieldNotifyTime) {
		fields = append(fields, order.FieldNotifyTime)
	}
	if m.FieldCleared(order.FieldExtensionID) {
		fields = append(fields, order.FieldExtensionID)
	}
	if m.FieldCleared(order.FieldNo) {
		fields = append(fields, order.FieldNo)
	}
	if m.FieldCleared(order.FieldChannelUserID) {
		fields = append(fields, order.FieldChannelUserID)
	}
	if m.FieldCleared(order.FieldChannelOrderNo) {
		fields = append(fields, order.FieldChannelOrderNo)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *OrderMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *OrderMutation) ClearField(name string) error {
	switch name {
	case order.FieldStatus:
		m.ClearStatus()
		return nil
	case order.FieldDeletedAt:
		m.ClearDeletedAt()
		return nil
	case order.FieldChannelID:
		m.ClearChannelID()
		return nil
	case order.FieldChannelCode:
		m.ClearChannelCode()
		return nil
	case order.FieldChannelFeeRate:
		m.ClearChannelFeeRate()
		return nil
	case order.FieldChannelFeePrice:
		m.ClearChannelFeePrice()
		return nil
	case order.FieldSuccessTime:
		m.ClearSuccessTime()
		return nil
	case order.FieldNotifyTime:
		m.ClearNotifyTime()
		return nil
	case order.FieldExtensionID:
		m.ClearExtensionID()
		return nil
	case order.FieldNo:
		m.ClearNo()
		return nil
	case order.FieldChannelUserID:
		m.ClearChannelUserID()
		return nil
	case order.FieldChannelOrderNo:
		m.ClearChannelOrderNo()
		return nil
	}
	return fmt.Errorf("unknown Order nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *OrderMutation) ResetField(name string) error {
	switch name {
	case order.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case order.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case order.FieldStatus:
		m.ResetStatus()
		return nil
	case order.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case order.FieldAppID:
		m.ResetAppID()
		return nil
	case order.FieldChannelID:
		m.ResetChannelID()
		return nil
	case order.FieldChannelCode:
		m.ResetChannelCode()
		return nil
	case order.FieldMerchantOrderID:
		m.ResetMerchantOrderID()
		return nil
	case order.FieldSubject:
		m.ResetSubject()
		return nil
	case order.FieldBody:
		m.ResetBody()
		return nil
	case order.FieldNotifyURL:
		m.ResetNotifyURL()
		return nil
	case order.FieldPrice:
		m.ResetPrice()
		return nil
	case order.FieldChannelFeeRate:
		m.ResetChannelFeeRate()
		return nil
	case order.FieldChannelFeePrice:
		m.ResetChannelFeePrice()
		return nil
	case order.FieldUserIP:
		m.ResetUserIP()
		return nil
	case order.FieldExpireTime:
		m.ResetExpireTime()
		return nil
	case order.FieldSuccessTime:
		m.ResetSuccessTime()
		return nil
	case order.FieldNotifyTime:
		m.ResetNotifyTime()
		return nil
	case order.FieldExtensionID:
		m.ResetExtensionID()
		return nil
	case order.FieldNo:
		m.ResetNo()
		return nil
	case order.FieldRefundPrice:
		m.ResetRefundPrice()
		return nil
	case order.FieldChannelUserID:
		m.ResetChannelUserID()
		return nil
	case order.FieldChannelOrderNo:
		m.ResetChannelOrderNo()
		return nil
	}
	return fmt.Errorf("unknown Order field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *OrderMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *OrderMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *OrderMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *OrderMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *OrderMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *OrderMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *OrderMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown Order unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *OrderMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown Order edge %s", name)
}

// OrderExtensionMutation represents an operation that mutates the OrderExtension nodes in the graph.
type OrderExtensionMutation struct {
	config
	op                  Op
	typ                 string
	id                  *uint64
	created_at          *time.Time
	updated_at          *time.Time
	status              *uint8
	addstatus           *int8
	deleted_at          *time.Time
	no                  *string
	order_id            *uint64
	addorder_id         *int64
	channel_id          *uint64
	addchannel_id       *int64
	channel_code        *string
	user_ip             *string
	channel_extras      *map[string]string
	channel_error_code  *string
	channel_error_msg   *string
	channel_notify_data *string
	clearedFields       map[string]struct{}
	done                bool
	oldValue            func(context.Context) (*OrderExtension, error)
	predicates          []predicate.OrderExtension
}

var _ ent.Mutation = (*OrderExtensionMutation)(nil)

// orderextensionOption allows management of the mutation configuration using functional options.
type orderextensionOption func(*OrderExtensionMutation)

// newOrderExtensionMutation creates new mutation for the OrderExtension entity.
func newOrderExtensionMutation(c config, op Op, opts ...orderextensionOption) *OrderExtensionMutation {
	m := &OrderExtensionMutation{
		config:        c,
		op:            op,
		typ:           TypeOrderExtension,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withOrderExtensionID sets the ID field of the mutation.
func withOrderExtensionID(id uint64) orderextensionOption {
	return func(m *OrderExtensionMutation) {
		var (
			err   error
			once  sync.Once
			value *OrderExtension
		)
		m.oldValue = func(ctx context.Context) (*OrderExtension, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().OrderExtension.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withOrderExtension sets the old OrderExtension of the mutation.
func withOrderExtension(node *OrderExtension) orderextensionOption {
	return func(m *OrderExtensionMutation) {
		m.oldValue = func(context.Context) (*OrderExtension, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m OrderExtensionMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m OrderExtensionMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of OrderExtension entities.
func (m *OrderExtensionMutation) SetID(id uint64) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *OrderExtensionMutation) ID() (id uint64, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *OrderExtensionMutation) IDs(ctx context.Context) ([]uint64, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uint64{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().OrderExtension.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *OrderExtensionMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *OrderExtensionMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the OrderExtension entity.
// If the OrderExtension object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrderExtensionMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *OrderExtensionMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *OrderExtensionMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *OrderExtensionMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the OrderExtension entity.
// If the OrderExtension object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrderExtensionMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *OrderExtensionMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetStatus sets the "status" field.
func (m *OrderExtensionMutation) SetStatus(u uint8) {
	m.status = &u
	m.addstatus = nil
}

// Status returns the value of the "status" field in the mutation.
func (m *OrderExtensionMutation) Status() (r uint8, exists bool) {
	v := m.status
	if v == nil {
		return
	}
	return *v, true
}

// OldStatus returns the old "status" field's value of the OrderExtension entity.
// If the OrderExtension object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrderExtensionMutation) OldStatus(ctx context.Context) (v uint8, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatus: %w", err)
	}
	return oldValue.Status, nil
}

// AddStatus adds u to the "status" field.
func (m *OrderExtensionMutation) AddStatus(u int8) {
	if m.addstatus != nil {
		*m.addstatus += u
	} else {
		m.addstatus = &u
	}
}

// AddedStatus returns the value that was added to the "status" field in this mutation.
func (m *OrderExtensionMutation) AddedStatus() (r int8, exists bool) {
	v := m.addstatus
	if v == nil {
		return
	}
	return *v, true
}

// ClearStatus clears the value of the "status" field.
func (m *OrderExtensionMutation) ClearStatus() {
	m.status = nil
	m.addstatus = nil
	m.clearedFields[orderextension.FieldStatus] = struct{}{}
}

// StatusCleared returns if the "status" field was cleared in this mutation.
func (m *OrderExtensionMutation) StatusCleared() bool {
	_, ok := m.clearedFields[orderextension.FieldStatus]
	return ok
}

// ResetStatus resets all changes to the "status" field.
func (m *OrderExtensionMutation) ResetStatus() {
	m.status = nil
	m.addstatus = nil
	delete(m.clearedFields, orderextension.FieldStatus)
}

// SetDeletedAt sets the "deleted_at" field.
func (m *OrderExtensionMutation) SetDeletedAt(t time.Time) {
	m.deleted_at = &t
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *OrderExtensionMutation) DeletedAt() (r time.Time, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the OrderExtension entity.
// If the OrderExtension object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrderExtensionMutation) OldDeletedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// ClearDeletedAt clears the value of the "deleted_at" field.
func (m *OrderExtensionMutation) ClearDeletedAt() {
	m.deleted_at = nil
	m.clearedFields[orderextension.FieldDeletedAt] = struct{}{}
}

// DeletedAtCleared returns if the "deleted_at" field was cleared in this mutation.
func (m *OrderExtensionMutation) DeletedAtCleared() bool {
	_, ok := m.clearedFields[orderextension.FieldDeletedAt]
	return ok
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *OrderExtensionMutation) ResetDeletedAt() {
	m.deleted_at = nil
	delete(m.clearedFields, orderextension.FieldDeletedAt)
}

// SetNo sets the "no" field.
func (m *OrderExtensionMutation) SetNo(s string) {
	m.no = &s
}

// No returns the value of the "no" field in the mutation.
func (m *OrderExtensionMutation) No() (r string, exists bool) {
	v := m.no
	if v == nil {
		return
	}
	return *v, true
}

// OldNo returns the old "no" field's value of the OrderExtension entity.
// If the OrderExtension object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrderExtensionMutation) OldNo(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldNo is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldNo requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldNo: %w", err)
	}
	return oldValue.No, nil
}

// ResetNo resets all changes to the "no" field.
func (m *OrderExtensionMutation) ResetNo() {
	m.no = nil
}

// SetOrderID sets the "order_id" field.
func (m *OrderExtensionMutation) SetOrderID(u uint64) {
	m.order_id = &u
	m.addorder_id = nil
}

// OrderID returns the value of the "order_id" field in the mutation.
func (m *OrderExtensionMutation) OrderID() (r uint64, exists bool) {
	v := m.order_id
	if v == nil {
		return
	}
	return *v, true
}

// OldOrderID returns the old "order_id" field's value of the OrderExtension entity.
// If the OrderExtension object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrderExtensionMutation) OldOrderID(ctx context.Context) (v uint64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOrderID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOrderID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOrderID: %w", err)
	}
	return oldValue.OrderID, nil
}

// AddOrderID adds u to the "order_id" field.
func (m *OrderExtensionMutation) AddOrderID(u int64) {
	if m.addorder_id != nil {
		*m.addorder_id += u
	} else {
		m.addorder_id = &u
	}
}

// AddedOrderID returns the value that was added to the "order_id" field in this mutation.
func (m *OrderExtensionMutation) AddedOrderID() (r int64, exists bool) {
	v := m.addorder_id
	if v == nil {
		return
	}
	return *v, true
}

// ResetOrderID resets all changes to the "order_id" field.
func (m *OrderExtensionMutation) ResetOrderID() {
	m.order_id = nil
	m.addorder_id = nil
}

// SetChannelID sets the "channel_id" field.
func (m *OrderExtensionMutation) SetChannelID(u uint64) {
	m.channel_id = &u
	m.addchannel_id = nil
}

// ChannelID returns the value of the "channel_id" field in the mutation.
func (m *OrderExtensionMutation) ChannelID() (r uint64, exists bool) {
	v := m.channel_id
	if v == nil {
		return
	}
	return *v, true
}

// OldChannelID returns the old "channel_id" field's value of the OrderExtension entity.
// If the OrderExtension object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrderExtensionMutation) OldChannelID(ctx context.Context) (v uint64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldChannelID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldChannelID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldChannelID: %w", err)
	}
	return oldValue.ChannelID, nil
}

// AddChannelID adds u to the "channel_id" field.
func (m *OrderExtensionMutation) AddChannelID(u int64) {
	if m.addchannel_id != nil {
		*m.addchannel_id += u
	} else {
		m.addchannel_id = &u
	}
}

// AddedChannelID returns the value that was added to the "channel_id" field in this mutation.
func (m *OrderExtensionMutation) AddedChannelID() (r int64, exists bool) {
	v := m.addchannel_id
	if v == nil {
		return
	}
	return *v, true
}

// ResetChannelID resets all changes to the "channel_id" field.
func (m *OrderExtensionMutation) ResetChannelID() {
	m.channel_id = nil
	m.addchannel_id = nil
}

// SetChannelCode sets the "channel_code" field.
func (m *OrderExtensionMutation) SetChannelCode(s string) {
	m.channel_code = &s
}

// ChannelCode returns the value of the "channel_code" field in the mutation.
func (m *OrderExtensionMutation) ChannelCode() (r string, exists bool) {
	v := m.channel_code
	if v == nil {
		return
	}
	return *v, true
}

// OldChannelCode returns the old "channel_code" field's value of the OrderExtension entity.
// If the OrderExtension object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrderExtensionMutation) OldChannelCode(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldChannelCode is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldChannelCode requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldChannelCode: %w", err)
	}
	return oldValue.ChannelCode, nil
}

// ResetChannelCode resets all changes to the "channel_code" field.
func (m *OrderExtensionMutation) ResetChannelCode() {
	m.channel_code = nil
}

// SetUserIP sets the "user_ip" field.
func (m *OrderExtensionMutation) SetUserIP(s string) {
	m.user_ip = &s
}

// UserIP returns the value of the "user_ip" field in the mutation.
func (m *OrderExtensionMutation) UserIP() (r string, exists bool) {
	v := m.user_ip
	if v == nil {
		return
	}
	return *v, true
}

// OldUserIP returns the old "user_ip" field's value of the OrderExtension entity.
// If the OrderExtension object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrderExtensionMutation) OldUserIP(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUserIP is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUserIP requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUserIP: %w", err)
	}
	return oldValue.UserIP, nil
}

// ResetUserIP resets all changes to the "user_ip" field.
func (m *OrderExtensionMutation) ResetUserIP() {
	m.user_ip = nil
}

// SetChannelExtras sets the "channel_extras" field.
func (m *OrderExtensionMutation) SetChannelExtras(value map[string]string) {
	m.channel_extras = &value
}

// ChannelExtras returns the value of the "channel_extras" field in the mutation.
func (m *OrderExtensionMutation) ChannelExtras() (r map[string]string, exists bool) {
	v := m.channel_extras
	if v == nil {
		return
	}
	return *v, true
}

// OldChannelExtras returns the old "channel_extras" field's value of the OrderExtension entity.
// If the OrderExtension object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrderExtensionMutation) OldChannelExtras(ctx context.Context) (v map[string]string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldChannelExtras is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldChannelExtras requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldChannelExtras: %w", err)
	}
	return oldValue.ChannelExtras, nil
}

// ClearChannelExtras clears the value of the "channel_extras" field.
func (m *OrderExtensionMutation) ClearChannelExtras() {
	m.channel_extras = nil
	m.clearedFields[orderextension.FieldChannelExtras] = struct{}{}
}

// ChannelExtrasCleared returns if the "channel_extras" field was cleared in this mutation.
func (m *OrderExtensionMutation) ChannelExtrasCleared() bool {
	_, ok := m.clearedFields[orderextension.FieldChannelExtras]
	return ok
}

// ResetChannelExtras resets all changes to the "channel_extras" field.
func (m *OrderExtensionMutation) ResetChannelExtras() {
	m.channel_extras = nil
	delete(m.clearedFields, orderextension.FieldChannelExtras)
}

// SetChannelErrorCode sets the "channel_error_code" field.
func (m *OrderExtensionMutation) SetChannelErrorCode(s string) {
	m.channel_error_code = &s
}

// ChannelErrorCode returns the value of the "channel_error_code" field in the mutation.
func (m *OrderExtensionMutation) ChannelErrorCode() (r string, exists bool) {
	v := m.channel_error_code
	if v == nil {
		return
	}
	return *v, true
}

// OldChannelErrorCode returns the old "channel_error_code" field's value of the OrderExtension entity.
// If the OrderExtension object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrderExtensionMutation) OldChannelErrorCode(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldChannelErrorCode is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldChannelErrorCode requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldChannelErrorCode: %w", err)
	}
	return oldValue.ChannelErrorCode, nil
}

// ClearChannelErrorCode clears the value of the "channel_error_code" field.
func (m *OrderExtensionMutation) ClearChannelErrorCode() {
	m.channel_error_code = nil
	m.clearedFields[orderextension.FieldChannelErrorCode] = struct{}{}
}

// ChannelErrorCodeCleared returns if the "channel_error_code" field was cleared in this mutation.
func (m *OrderExtensionMutation) ChannelErrorCodeCleared() bool {
	_, ok := m.clearedFields[orderextension.FieldChannelErrorCode]
	return ok
}

// ResetChannelErrorCode resets all changes to the "channel_error_code" field.
func (m *OrderExtensionMutation) ResetChannelErrorCode() {
	m.channel_error_code = nil
	delete(m.clearedFields, orderextension.FieldChannelErrorCode)
}

// SetChannelErrorMsg sets the "channel_error_msg" field.
func (m *OrderExtensionMutation) SetChannelErrorMsg(s string) {
	m.channel_error_msg = &s
}

// ChannelErrorMsg returns the value of the "channel_error_msg" field in the mutation.
func (m *OrderExtensionMutation) ChannelErrorMsg() (r string, exists bool) {
	v := m.channel_error_msg
	if v == nil {
		return
	}
	return *v, true
}

// OldChannelErrorMsg returns the old "channel_error_msg" field's value of the OrderExtension entity.
// If the OrderExtension object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrderExtensionMutation) OldChannelErrorMsg(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldChannelErrorMsg is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldChannelErrorMsg requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldChannelErrorMsg: %w", err)
	}
	return oldValue.ChannelErrorMsg, nil
}

// ClearChannelErrorMsg clears the value of the "channel_error_msg" field.
func (m *OrderExtensionMutation) ClearChannelErrorMsg() {
	m.channel_error_msg = nil
	m.clearedFields[orderextension.FieldChannelErrorMsg] = struct{}{}
}

// ChannelErrorMsgCleared returns if the "channel_error_msg" field was cleared in this mutation.
func (m *OrderExtensionMutation) ChannelErrorMsgCleared() bool {
	_, ok := m.clearedFields[orderextension.FieldChannelErrorMsg]
	return ok
}

// ResetChannelErrorMsg resets all changes to the "channel_error_msg" field.
func (m *OrderExtensionMutation) ResetChannelErrorMsg() {
	m.channel_error_msg = nil
	delete(m.clearedFields, orderextension.FieldChannelErrorMsg)
}

// SetChannelNotifyData sets the "channel_notify_data" field.
func (m *OrderExtensionMutation) SetChannelNotifyData(s string) {
	m.channel_notify_data = &s
}

// ChannelNotifyData returns the value of the "channel_notify_data" field in the mutation.
func (m *OrderExtensionMutation) ChannelNotifyData() (r string, exists bool) {
	v := m.channel_notify_data
	if v == nil {
		return
	}
	return *v, true
}

// OldChannelNotifyData returns the old "channel_notify_data" field's value of the OrderExtension entity.
// If the OrderExtension object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrderExtensionMutation) OldChannelNotifyData(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldChannelNotifyData is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldChannelNotifyData requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldChannelNotifyData: %w", err)
	}
	return oldValue.ChannelNotifyData, nil
}

// ClearChannelNotifyData clears the value of the "channel_notify_data" field.
func (m *OrderExtensionMutation) ClearChannelNotifyData() {
	m.channel_notify_data = nil
	m.clearedFields[orderextension.FieldChannelNotifyData] = struct{}{}
}

// ChannelNotifyDataCleared returns if the "channel_notify_data" field was cleared in this mutation.
func (m *OrderExtensionMutation) ChannelNotifyDataCleared() bool {
	_, ok := m.clearedFields[orderextension.FieldChannelNotifyData]
	return ok
}

// ResetChannelNotifyData resets all changes to the "channel_notify_data" field.
func (m *OrderExtensionMutation) ResetChannelNotifyData() {
	m.channel_notify_data = nil
	delete(m.clearedFields, orderextension.FieldChannelNotifyData)
}

// Where appends a list predicates to the OrderExtensionMutation builder.
func (m *OrderExtensionMutation) Where(ps ...predicate.OrderExtension) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the OrderExtensionMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *OrderExtensionMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.OrderExtension, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *OrderExtensionMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *OrderExtensionMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (OrderExtension).
func (m *OrderExtensionMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *OrderExtensionMutation) Fields() []string {
	fields := make([]string, 0, 13)
	if m.created_at != nil {
		fields = append(fields, orderextension.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, orderextension.FieldUpdatedAt)
	}
	if m.status != nil {
		fields = append(fields, orderextension.FieldStatus)
	}
	if m.deleted_at != nil {
		fields = append(fields, orderextension.FieldDeletedAt)
	}
	if m.no != nil {
		fields = append(fields, orderextension.FieldNo)
	}
	if m.order_id != nil {
		fields = append(fields, orderextension.FieldOrderID)
	}
	if m.channel_id != nil {
		fields = append(fields, orderextension.FieldChannelID)
	}
	if m.channel_code != nil {
		fields = append(fields, orderextension.FieldChannelCode)
	}
	if m.user_ip != nil {
		fields = append(fields, orderextension.FieldUserIP)
	}
	if m.channel_extras != nil {
		fields = append(fields, orderextension.FieldChannelExtras)
	}
	if m.channel_error_code != nil {
		fields = append(fields, orderextension.FieldChannelErrorCode)
	}
	if m.channel_error_msg != nil {
		fields = append(fields, orderextension.FieldChannelErrorMsg)
	}
	if m.channel_notify_data != nil {
		fields = append(fields, orderextension.FieldChannelNotifyData)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *OrderExtensionMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case orderextension.FieldCreatedAt:
		return m.CreatedAt()
	case orderextension.FieldUpdatedAt:
		return m.UpdatedAt()
	case orderextension.FieldStatus:
		return m.Status()
	case orderextension.FieldDeletedAt:
		return m.DeletedAt()
	case orderextension.FieldNo:
		return m.No()
	case orderextension.FieldOrderID:
		return m.OrderID()
	case orderextension.FieldChannelID:
		return m.ChannelID()
	case orderextension.FieldChannelCode:
		return m.ChannelCode()
	case orderextension.FieldUserIP:
		return m.UserIP()
	case orderextension.FieldChannelExtras:
		return m.ChannelExtras()
	case orderextension.FieldChannelErrorCode:
		return m.ChannelErrorCode()
	case orderextension.FieldChannelErrorMsg:
		return m.ChannelErrorMsg()
	case orderextension.FieldChannelNotifyData:
		return m.ChannelNotifyData()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *OrderExtensionMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case orderextension.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case orderextension.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case orderextension.FieldStatus:
		return m.OldStatus(ctx)
	case orderextension.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case orderextension.FieldNo:
		return m.OldNo(ctx)
	case orderextension.FieldOrderID:
		return m.OldOrderID(ctx)
	case orderextension.FieldChannelID:
		return m.OldChannelID(ctx)
	case orderextension.FieldChannelCode:
		return m.OldChannelCode(ctx)
	case orderextension.FieldUserIP:
		return m.OldUserIP(ctx)
	case orderextension.FieldChannelExtras:
		return m.OldChannelExtras(ctx)
	case orderextension.FieldChannelErrorCode:
		return m.OldChannelErrorCode(ctx)
	case orderextension.FieldChannelErrorMsg:
		return m.OldChannelErrorMsg(ctx)
	case orderextension.FieldChannelNotifyData:
		return m.OldChannelNotifyData(ctx)
	}
	return nil, fmt.Errorf("unknown OrderExtension field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *OrderExtensionMutation) SetField(name string, value ent.Value) error {
	switch name {
	case orderextension.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case orderextension.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case orderextension.FieldStatus:
		v, ok := value.(uint8)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatus(v)
		return nil
	case orderextension.FieldDeletedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case orderextension.FieldNo:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetNo(v)
		return nil
	case orderextension.FieldOrderID:
		v, ok := value.(uint64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOrderID(v)
		return nil
	case orderextension.FieldChannelID:
		v, ok := value.(uint64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetChannelID(v)
		return nil
	case orderextension.FieldChannelCode:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetChannelCode(v)
		return nil
	case orderextension.FieldUserIP:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUserIP(v)
		return nil
	case orderextension.FieldChannelExtras:
		v, ok := value.(map[string]string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetChannelExtras(v)
		return nil
	case orderextension.FieldChannelErrorCode:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetChannelErrorCode(v)
		return nil
	case orderextension.FieldChannelErrorMsg:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetChannelErrorMsg(v)
		return nil
	case orderextension.FieldChannelNotifyData:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetChannelNotifyData(v)
		return nil
	}
	return fmt.Errorf("unknown OrderExtension field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *OrderExtensionMutation) AddedFields() []string {
	var fields []string
	if m.addstatus != nil {
		fields = append(fields, orderextension.FieldStatus)
	}
	if m.addorder_id != nil {
		fields = append(fields, orderextension.FieldOrderID)
	}
	if m.addchannel_id != nil {
		fields = append(fields, orderextension.FieldChannelID)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *OrderExtensionMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case orderextension.FieldStatus:
		return m.AddedStatus()
	case orderextension.FieldOrderID:
		return m.AddedOrderID()
	case orderextension.FieldChannelID:
		return m.AddedChannelID()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *OrderExtensionMutation) AddField(name string, value ent.Value) error {
	switch name {
	case orderextension.FieldStatus:
		v, ok := value.(int8)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddStatus(v)
		return nil
	case orderextension.FieldOrderID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddOrderID(v)
		return nil
	case orderextension.FieldChannelID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddChannelID(v)
		return nil
	}
	return fmt.Errorf("unknown OrderExtension numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *OrderExtensionMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(orderextension.FieldStatus) {
		fields = append(fields, orderextension.FieldStatus)
	}
	if m.FieldCleared(orderextension.FieldDeletedAt) {
		fields = append(fields, orderextension.FieldDeletedAt)
	}
	if m.FieldCleared(orderextension.FieldChannelExtras) {
		fields = append(fields, orderextension.FieldChannelExtras)
	}
	if m.FieldCleared(orderextension.FieldChannelErrorCode) {
		fields = append(fields, orderextension.FieldChannelErrorCode)
	}
	if m.FieldCleared(orderextension.FieldChannelErrorMsg) {
		fields = append(fields, orderextension.FieldChannelErrorMsg)
	}
	if m.FieldCleared(orderextension.FieldChannelNotifyData) {
		fields = append(fields, orderextension.FieldChannelNotifyData)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *OrderExtensionMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *OrderExtensionMutation) ClearField(name string) error {
	switch name {
	case orderextension.FieldStatus:
		m.ClearStatus()
		return nil
	case orderextension.FieldDeletedAt:
		m.ClearDeletedAt()
		return nil
	case orderextension.FieldChannelExtras:
		m.ClearChannelExtras()
		return nil
	case orderextension.FieldChannelErrorCode:
		m.ClearChannelErrorCode()
		return nil
	case orderextension.FieldChannelErrorMsg:
		m.ClearChannelErrorMsg()
		return nil
	case orderextension.FieldChannelNotifyData:
		m.ClearChannelNotifyData()
		return nil
	}
	return fmt.Errorf("unknown OrderExtension nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *OrderExtensionMutation) ResetField(name string) error {
	switch name {
	case orderextension.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case orderextension.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case orderextension.FieldStatus:
		m.ResetStatus()
		return nil
	case orderextension.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case orderextension.FieldNo:
		m.ResetNo()
		return nil
	case orderextension.FieldOrderID:
		m.ResetOrderID()
		return nil
	case orderextension.FieldChannelID:
		m.ResetChannelID()
		return nil
	case orderextension.FieldChannelCode:
		m.ResetChannelCode()
		return nil
	case orderextension.FieldUserIP:
		m.ResetUserIP()
		return nil
	case orderextension.FieldChannelExtras:
		m.ResetChannelExtras()
		return nil
	case orderextension.FieldChannelErrorCode:
		m.ResetChannelErrorCode()
		return nil
	case orderextension.FieldChannelErrorMsg:
		m.ResetChannelErrorMsg()
		return nil
	case orderextension.FieldChannelNotifyData:
		m.ResetChannelNotifyData()
		return nil
	}
	return fmt.Errorf("unknown OrderExtension field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *OrderExtensionMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *OrderExtensionMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *OrderExtensionMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *OrderExtensionMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *OrderExtensionMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *OrderExtensionMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *OrderExtensionMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown OrderExtension unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *OrderExtensionMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown OrderExtension edge %s", name)
}

// RefundMutation represents an operation that mutates the Refund nodes in the graph.
type RefundMutation struct {
	config
	op                  Op
	typ                 string
	id                  *uint64
	created_at          *time.Time
	updated_at          *time.Time
	status              *uint8
	addstatus           *int8
	deleted_at          *time.Time
	no                  *string
	app_id              *uint64
	addapp_id           *int64
	channel_id          *uint64
	addchannel_id       *int64
	channel_code        *string
	order_id            *uint64
	addorder_id         *int64
	order_no            *string
	merchant_order_id   *string
	merchant_refund_id  *string
	notify_url          *string
	pay_price           *int32
	addpay_price        *int32
	refund_price        *int32
	addrefund_price     *int32
	reason              *string
	user_ip             *string
	channel_order_no    *string
	channel_refund_no   *string
	success_time        *time.Time
	channel_error_code  *string
	channel_error_msg   *string
	channel_notify_data *string
	clearedFields       map[string]struct{}
	done                bool
	oldValue            func(context.Context) (*Refund, error)
	predicates          []predicate.Refund
}

var _ ent.Mutation = (*RefundMutation)(nil)

// refundOption allows management of the mutation configuration using functional options.
type refundOption func(*RefundMutation)

// newRefundMutation creates new mutation for the Refund entity.
func newRefundMutation(c config, op Op, opts ...refundOption) *RefundMutation {
	m := &RefundMutation{
		config:        c,
		op:            op,
		typ:           TypeRefund,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withRefundID sets the ID field of the mutation.
func withRefundID(id uint64) refundOption {
	return func(m *RefundMutation) {
		var (
			err   error
			once  sync.Once
			value *Refund
		)
		m.oldValue = func(ctx context.Context) (*Refund, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Refund.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withRefund sets the old Refund of the mutation.
func withRefund(node *Refund) refundOption {
	return func(m *RefundMutation) {
		m.oldValue = func(context.Context) (*Refund, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m RefundMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m RefundMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Refund entities.
func (m *RefundMutation) SetID(id uint64) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *RefundMutation) ID() (id uint64, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *RefundMutation) IDs(ctx context.Context) ([]uint64, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uint64{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Refund.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *RefundMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *RefundMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Refund entity.
// If the Refund object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RefundMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *RefundMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *RefundMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *RefundMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Refund entity.
// If the Refund object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RefundMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *RefundMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetStatus sets the "status" field.
func (m *RefundMutation) SetStatus(u uint8) {
	m.status = &u
	m.addstatus = nil
}

// Status returns the value of the "status" field in the mutation.
func (m *RefundMutation) Status() (r uint8, exists bool) {
	v := m.status
	if v == nil {
		return
	}
	return *v, true
}

// OldStatus returns the old "status" field's value of the Refund entity.
// If the Refund object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RefundMutation) OldStatus(ctx context.Context) (v uint8, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatus: %w", err)
	}
	return oldValue.Status, nil
}

// AddStatus adds u to the "status" field.
func (m *RefundMutation) AddStatus(u int8) {
	if m.addstatus != nil {
		*m.addstatus += u
	} else {
		m.addstatus = &u
	}
}

// AddedStatus returns the value that was added to the "status" field in this mutation.
func (m *RefundMutation) AddedStatus() (r int8, exists bool) {
	v := m.addstatus
	if v == nil {
		return
	}
	return *v, true
}

// ClearStatus clears the value of the "status" field.
func (m *RefundMutation) ClearStatus() {
	m.status = nil
	m.addstatus = nil
	m.clearedFields[refund.FieldStatus] = struct{}{}
}

// StatusCleared returns if the "status" field was cleared in this mutation.
func (m *RefundMutation) StatusCleared() bool {
	_, ok := m.clearedFields[refund.FieldStatus]
	return ok
}

// ResetStatus resets all changes to the "status" field.
func (m *RefundMutation) ResetStatus() {
	m.status = nil
	m.addstatus = nil
	delete(m.clearedFields, refund.FieldStatus)
}

// SetDeletedAt sets the "deleted_at" field.
func (m *RefundMutation) SetDeletedAt(t time.Time) {
	m.deleted_at = &t
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *RefundMutation) DeletedAt() (r time.Time, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the Refund entity.
// If the Refund object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RefundMutation) OldDeletedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// ClearDeletedAt clears the value of the "deleted_at" field.
func (m *RefundMutation) ClearDeletedAt() {
	m.deleted_at = nil
	m.clearedFields[refund.FieldDeletedAt] = struct{}{}
}

// DeletedAtCleared returns if the "deleted_at" field was cleared in this mutation.
func (m *RefundMutation) DeletedAtCleared() bool {
	_, ok := m.clearedFields[refund.FieldDeletedAt]
	return ok
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *RefundMutation) ResetDeletedAt() {
	m.deleted_at = nil
	delete(m.clearedFields, refund.FieldDeletedAt)
}

// SetNo sets the "no" field.
func (m *RefundMutation) SetNo(s string) {
	m.no = &s
}

// No returns the value of the "no" field in the mutation.
func (m *RefundMutation) No() (r string, exists bool) {
	v := m.no
	if v == nil {
		return
	}
	return *v, true
}

// OldNo returns the old "no" field's value of the Refund entity.
// If the Refund object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RefundMutation) OldNo(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldNo is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldNo requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldNo: %w", err)
	}
	return oldValue.No, nil
}

// ResetNo resets all changes to the "no" field.
func (m *RefundMutation) ResetNo() {
	m.no = nil
}

// SetAppID sets the "app_id" field.
func (m *RefundMutation) SetAppID(u uint64) {
	m.app_id = &u
	m.addapp_id = nil
}

// AppID returns the value of the "app_id" field in the mutation.
func (m *RefundMutation) AppID() (r uint64, exists bool) {
	v := m.app_id
	if v == nil {
		return
	}
	return *v, true
}

// OldAppID returns the old "app_id" field's value of the Refund entity.
// If the Refund object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RefundMutation) OldAppID(ctx context.Context) (v uint64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAppID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAppID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAppID: %w", err)
	}
	return oldValue.AppID, nil
}

// AddAppID adds u to the "app_id" field.
func (m *RefundMutation) AddAppID(u int64) {
	if m.addapp_id != nil {
		*m.addapp_id += u
	} else {
		m.addapp_id = &u
	}
}

// AddedAppID returns the value that was added to the "app_id" field in this mutation.
func (m *RefundMutation) AddedAppID() (r int64, exists bool) {
	v := m.addapp_id
	if v == nil {
		return
	}
	return *v, true
}

// ResetAppID resets all changes to the "app_id" field.
func (m *RefundMutation) ResetAppID() {
	m.app_id = nil
	m.addapp_id = nil
}

// SetChannelID sets the "channel_id" field.
func (m *RefundMutation) SetChannelID(u uint64) {
	m.channel_id = &u
	m.addchannel_id = nil
}

// ChannelID returns the value of the "channel_id" field in the mutation.
func (m *RefundMutation) ChannelID() (r uint64, exists bool) {
	v := m.channel_id
	if v == nil {
		return
	}
	return *v, true
}

// OldChannelID returns the old "channel_id" field's value of the Refund entity.
// If the Refund object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RefundMutation) OldChannelID(ctx context.Context) (v uint64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldChannelID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldChannelID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldChannelID: %w", err)
	}
	return oldValue.ChannelID, nil
}

// AddChannelID adds u to the "channel_id" field.
func (m *RefundMutation) AddChannelID(u int64) {
	if m.addchannel_id != nil {
		*m.addchannel_id += u
	} else {
		m.addchannel_id = &u
	}
}

// AddedChannelID returns the value that was added to the "channel_id" field in this mutation.
func (m *RefundMutation) AddedChannelID() (r int64, exists bool) {
	v := m.addchannel_id
	if v == nil {
		return
	}
	return *v, true
}

// ResetChannelID resets all changes to the "channel_id" field.
func (m *RefundMutation) ResetChannelID() {
	m.channel_id = nil
	m.addchannel_id = nil
}

// SetChannelCode sets the "channel_code" field.
func (m *RefundMutation) SetChannelCode(s string) {
	m.channel_code = &s
}

// ChannelCode returns the value of the "channel_code" field in the mutation.
func (m *RefundMutation) ChannelCode() (r string, exists bool) {
	v := m.channel_code
	if v == nil {
		return
	}
	return *v, true
}

// OldChannelCode returns the old "channel_code" field's value of the Refund entity.
// If the Refund object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RefundMutation) OldChannelCode(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldChannelCode is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldChannelCode requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldChannelCode: %w", err)
	}
	return oldValue.ChannelCode, nil
}

// ResetChannelCode resets all changes to the "channel_code" field.
func (m *RefundMutation) ResetChannelCode() {
	m.channel_code = nil
}

// SetOrderID sets the "order_id" field.
func (m *RefundMutation) SetOrderID(u uint64) {
	m.order_id = &u
	m.addorder_id = nil
}

// OrderID returns the value of the "order_id" field in the mutation.
func (m *RefundMutation) OrderID() (r uint64, exists bool) {
	v := m.order_id
	if v == nil {
		return
	}
	return *v, true
}

// OldOrderID returns the old "order_id" field's value of the Refund entity.
// If the Refund object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RefundMutation) OldOrderID(ctx context.Context) (v uint64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOrderID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOrderID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOrderID: %w", err)
	}
	return oldValue.OrderID, nil
}

// AddOrderID adds u to the "order_id" field.
func (m *RefundMutation) AddOrderID(u int64) {
	if m.addorder_id != nil {
		*m.addorder_id += u
	} else {
		m.addorder_id = &u
	}
}

// AddedOrderID returns the value that was added to the "order_id" field in this mutation.
func (m *RefundMutation) AddedOrderID() (r int64, exists bool) {
	v := m.addorder_id
	if v == nil {
		return
	}
	return *v, true
}

// ResetOrderID resets all changes to the "order_id" field.
func (m *RefundMutation) ResetOrderID() {
	m.order_id = nil
	m.addorder_id = nil
}

// SetOrderNo sets the "order_no" field.
func (m *RefundMutation) SetOrderNo(s string) {
	m.order_no = &s
}

// OrderNo returns the value of the "order_no" field in the mutation.
func (m *RefundMutation) OrderNo() (r string, exists bool) {
	v := m.order_no
	if v == nil {
		return
	}
	return *v, true
}

// OldOrderNo returns the old "order_no" field's value of the Refund entity.
// If the Refund object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RefundMutation) OldOrderNo(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOrderNo is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOrderNo requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOrderNo: %w", err)
	}
	return oldValue.OrderNo, nil
}

// ResetOrderNo resets all changes to the "order_no" field.
func (m *RefundMutation) ResetOrderNo() {
	m.order_no = nil
}

// SetMerchantOrderID sets the "merchant_order_id" field.
func (m *RefundMutation) SetMerchantOrderID(s string) {
	m.merchant_order_id = &s
}

// MerchantOrderID returns the value of the "merchant_order_id" field in the mutation.
func (m *RefundMutation) MerchantOrderID() (r string, exists bool) {
	v := m.merchant_order_id
	if v == nil {
		return
	}
	return *v, true
}

// OldMerchantOrderID returns the old "merchant_order_id" field's value of the Refund entity.
// If the Refund object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RefundMutation) OldMerchantOrderID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMerchantOrderID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMerchantOrderID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMerchantOrderID: %w", err)
	}
	return oldValue.MerchantOrderID, nil
}

// ResetMerchantOrderID resets all changes to the "merchant_order_id" field.
func (m *RefundMutation) ResetMerchantOrderID() {
	m.merchant_order_id = nil
}

// SetMerchantRefundID sets the "merchant_refund_id" field.
func (m *RefundMutation) SetMerchantRefundID(s string) {
	m.merchant_refund_id = &s
}

// MerchantRefundID returns the value of the "merchant_refund_id" field in the mutation.
func (m *RefundMutation) MerchantRefundID() (r string, exists bool) {
	v := m.merchant_refund_id
	if v == nil {
		return
	}
	return *v, true
}

// OldMerchantRefundID returns the old "merchant_refund_id" field's value of the Refund entity.
// If the Refund object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RefundMutation) OldMerchantRefundID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMerchantRefundID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMerchantRefundID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMerchantRefundID: %w", err)
	}
	return oldValue.MerchantRefundID, nil
}

// ResetMerchantRefundID resets all changes to the "merchant_refund_id" field.
func (m *RefundMutation) ResetMerchantRefundID() {
	m.merchant_refund_id = nil
}

// SetNotifyURL sets the "notify_url" field.
func (m *RefundMutation) SetNotifyURL(s string) {
	m.notify_url = &s
}

// NotifyURL returns the value of the "notify_url" field in the mutation.
func (m *RefundMutation) NotifyURL() (r string, exists bool) {
	v := m.notify_url
	if v == nil {
		return
	}
	return *v, true
}

// OldNotifyURL returns the old "notify_url" field's value of the Refund entity.
// If the Refund object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RefundMutation) OldNotifyURL(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldNotifyURL is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldNotifyURL requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldNotifyURL: %w", err)
	}
	return oldValue.NotifyURL, nil
}

// ResetNotifyURL resets all changes to the "notify_url" field.
func (m *RefundMutation) ResetNotifyURL() {
	m.notify_url = nil
}

// SetPayPrice sets the "pay_price" field.
func (m *RefundMutation) SetPayPrice(i int32) {
	m.pay_price = &i
	m.addpay_price = nil
}

// PayPrice returns the value of the "pay_price" field in the mutation.
func (m *RefundMutation) PayPrice() (r int32, exists bool) {
	v := m.pay_price
	if v == nil {
		return
	}
	return *v, true
}

// OldPayPrice returns the old "pay_price" field's value of the Refund entity.
// If the Refund object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RefundMutation) OldPayPrice(ctx context.Context) (v int32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPayPrice is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPayPrice requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPayPrice: %w", err)
	}
	return oldValue.PayPrice, nil
}

// AddPayPrice adds i to the "pay_price" field.
func (m *RefundMutation) AddPayPrice(i int32) {
	if m.addpay_price != nil {
		*m.addpay_price += i
	} else {
		m.addpay_price = &i
	}
}

// AddedPayPrice returns the value that was added to the "pay_price" field in this mutation.
func (m *RefundMutation) AddedPayPrice() (r int32, exists bool) {
	v := m.addpay_price
	if v == nil {
		return
	}
	return *v, true
}

// ResetPayPrice resets all changes to the "pay_price" field.
func (m *RefundMutation) ResetPayPrice() {
	m.pay_price = nil
	m.addpay_price = nil
}

// SetRefundPrice sets the "refund_price" field.
func (m *RefundMutation) SetRefundPrice(i int32) {
	m.refund_price = &i
	m.addrefund_price = nil
}

// RefundPrice returns the value of the "refund_price" field in the mutation.
func (m *RefundMutation) RefundPrice() (r int32, exists bool) {
	v := m.refund_price
	if v == nil {
		return
	}
	return *v, true
}

// OldRefundPrice returns the old "refund_price" field's value of the Refund entity.
// If the Refund object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RefundMutation) OldRefundPrice(ctx context.Context) (v int32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRefundPrice is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRefundPrice requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRefundPrice: %w", err)
	}
	return oldValue.RefundPrice, nil
}

// AddRefundPrice adds i to the "refund_price" field.
func (m *RefundMutation) AddRefundPrice(i int32) {
	if m.addrefund_price != nil {
		*m.addrefund_price += i
	} else {
		m.addrefund_price = &i
	}
}

// AddedRefundPrice returns the value that was added to the "refund_price" field in this mutation.
func (m *RefundMutation) AddedRefundPrice() (r int32, exists bool) {
	v := m.addrefund_price
	if v == nil {
		return
	}
	return *v, true
}

// ResetRefundPrice resets all changes to the "refund_price" field.
func (m *RefundMutation) ResetRefundPrice() {
	m.refund_price = nil
	m.addrefund_price = nil
}

// SetReason sets the "reason" field.
func (m *RefundMutation) SetReason(s string) {
	m.reason = &s
}

// Reason returns the value of the "reason" field in the mutation.
func (m *RefundMutation) Reason() (r string, exists bool) {
	v := m.reason
	if v == nil {
		return
	}
	return *v, true
}

// OldReason returns the old "reason" field's value of the Refund entity.
// If the Refund object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RefundMutation) OldReason(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldReason is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldReason requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldReason: %w", err)
	}
	return oldValue.Reason, nil
}

// ResetReason resets all changes to the "reason" field.
func (m *RefundMutation) ResetReason() {
	m.reason = nil
}

// SetUserIP sets the "user_ip" field.
func (m *RefundMutation) SetUserIP(s string) {
	m.user_ip = &s
}

// UserIP returns the value of the "user_ip" field in the mutation.
func (m *RefundMutation) UserIP() (r string, exists bool) {
	v := m.user_ip
	if v == nil {
		return
	}
	return *v, true
}

// OldUserIP returns the old "user_ip" field's value of the Refund entity.
// If the Refund object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RefundMutation) OldUserIP(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUserIP is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUserIP requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUserIP: %w", err)
	}
	return oldValue.UserIP, nil
}

// ClearUserIP clears the value of the "user_ip" field.
func (m *RefundMutation) ClearUserIP() {
	m.user_ip = nil
	m.clearedFields[refund.FieldUserIP] = struct{}{}
}

// UserIPCleared returns if the "user_ip" field was cleared in this mutation.
func (m *RefundMutation) UserIPCleared() bool {
	_, ok := m.clearedFields[refund.FieldUserIP]
	return ok
}

// ResetUserIP resets all changes to the "user_ip" field.
func (m *RefundMutation) ResetUserIP() {
	m.user_ip = nil
	delete(m.clearedFields, refund.FieldUserIP)
}

// SetChannelOrderNo sets the "channel_order_no" field.
func (m *RefundMutation) SetChannelOrderNo(s string) {
	m.channel_order_no = &s
}

// ChannelOrderNo returns the value of the "channel_order_no" field in the mutation.
func (m *RefundMutation) ChannelOrderNo() (r string, exists bool) {
	v := m.channel_order_no
	if v == nil {
		return
	}
	return *v, true
}

// OldChannelOrderNo returns the old "channel_order_no" field's value of the Refund entity.
// If the Refund object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RefundMutation) OldChannelOrderNo(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldChannelOrderNo is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldChannelOrderNo requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldChannelOrderNo: %w", err)
	}
	return oldValue.ChannelOrderNo, nil
}

// ResetChannelOrderNo resets all changes to the "channel_order_no" field.
func (m *RefundMutation) ResetChannelOrderNo() {
	m.channel_order_no = nil
}

// SetChannelRefundNo sets the "channel_refund_no" field.
func (m *RefundMutation) SetChannelRefundNo(s string) {
	m.channel_refund_no = &s
}

// ChannelRefundNo returns the value of the "channel_refund_no" field in the mutation.
func (m *RefundMutation) ChannelRefundNo() (r string, exists bool) {
	v := m.channel_refund_no
	if v == nil {
		return
	}
	return *v, true
}

// OldChannelRefundNo returns the old "channel_refund_no" field's value of the Refund entity.
// If the Refund object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RefundMutation) OldChannelRefundNo(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldChannelRefundNo is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldChannelRefundNo requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldChannelRefundNo: %w", err)
	}
	return oldValue.ChannelRefundNo, nil
}

// ClearChannelRefundNo clears the value of the "channel_refund_no" field.
func (m *RefundMutation) ClearChannelRefundNo() {
	m.channel_refund_no = nil
	m.clearedFields[refund.FieldChannelRefundNo] = struct{}{}
}

// ChannelRefundNoCleared returns if the "channel_refund_no" field was cleared in this mutation.
func (m *RefundMutation) ChannelRefundNoCleared() bool {
	_, ok := m.clearedFields[refund.FieldChannelRefundNo]
	return ok
}

// ResetChannelRefundNo resets all changes to the "channel_refund_no" field.
func (m *RefundMutation) ResetChannelRefundNo() {
	m.channel_refund_no = nil
	delete(m.clearedFields, refund.FieldChannelRefundNo)
}

// SetSuccessTime sets the "success_time" field.
func (m *RefundMutation) SetSuccessTime(t time.Time) {
	m.success_time = &t
}

// SuccessTime returns the value of the "success_time" field in the mutation.
func (m *RefundMutation) SuccessTime() (r time.Time, exists bool) {
	v := m.success_time
	if v == nil {
		return
	}
	return *v, true
}

// OldSuccessTime returns the old "success_time" field's value of the Refund entity.
// If the Refund object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RefundMutation) OldSuccessTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSuccessTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSuccessTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSuccessTime: %w", err)
	}
	return oldValue.SuccessTime, nil
}

// ClearSuccessTime clears the value of the "success_time" field.
func (m *RefundMutation) ClearSuccessTime() {
	m.success_time = nil
	m.clearedFields[refund.FieldSuccessTime] = struct{}{}
}

// SuccessTimeCleared returns if the "success_time" field was cleared in this mutation.
func (m *RefundMutation) SuccessTimeCleared() bool {
	_, ok := m.clearedFields[refund.FieldSuccessTime]
	return ok
}

// ResetSuccessTime resets all changes to the "success_time" field.
func (m *RefundMutation) ResetSuccessTime() {
	m.success_time = nil
	delete(m.clearedFields, refund.FieldSuccessTime)
}

// SetChannelErrorCode sets the "channel_error_code" field.
func (m *RefundMutation) SetChannelErrorCode(s string) {
	m.channel_error_code = &s
}

// ChannelErrorCode returns the value of the "channel_error_code" field in the mutation.
func (m *RefundMutation) ChannelErrorCode() (r string, exists bool) {
	v := m.channel_error_code
	if v == nil {
		return
	}
	return *v, true
}

// OldChannelErrorCode returns the old "channel_error_code" field's value of the Refund entity.
// If the Refund object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RefundMutation) OldChannelErrorCode(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldChannelErrorCode is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldChannelErrorCode requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldChannelErrorCode: %w", err)
	}
	return oldValue.ChannelErrorCode, nil
}

// ClearChannelErrorCode clears the value of the "channel_error_code" field.
func (m *RefundMutation) ClearChannelErrorCode() {
	m.channel_error_code = nil
	m.clearedFields[refund.FieldChannelErrorCode] = struct{}{}
}

// ChannelErrorCodeCleared returns if the "channel_error_code" field was cleared in this mutation.
func (m *RefundMutation) ChannelErrorCodeCleared() bool {
	_, ok := m.clearedFields[refund.FieldChannelErrorCode]
	return ok
}

// ResetChannelErrorCode resets all changes to the "channel_error_code" field.
func (m *RefundMutation) ResetChannelErrorCode() {
	m.channel_error_code = nil
	delete(m.clearedFields, refund.FieldChannelErrorCode)
}

// SetChannelErrorMsg sets the "channel_error_msg" field.
func (m *RefundMutation) SetChannelErrorMsg(s string) {
	m.channel_error_msg = &s
}

// ChannelErrorMsg returns the value of the "channel_error_msg" field in the mutation.
func (m *RefundMutation) ChannelErrorMsg() (r string, exists bool) {
	v := m.channel_error_msg
	if v == nil {
		return
	}
	return *v, true
}

// OldChannelErrorMsg returns the old "channel_error_msg" field's value of the Refund entity.
// If the Refund object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RefundMutation) OldChannelErrorMsg(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldChannelErrorMsg is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldChannelErrorMsg requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldChannelErrorMsg: %w", err)
	}
	return oldValue.ChannelErrorMsg, nil
}

// ClearChannelErrorMsg clears the value of the "channel_error_msg" field.
func (m *RefundMutation) ClearChannelErrorMsg() {
	m.channel_error_msg = nil
	m.clearedFields[refund.FieldChannelErrorMsg] = struct{}{}
}

// ChannelErrorMsgCleared returns if the "channel_error_msg" field was cleared in this mutation.
func (m *RefundMutation) ChannelErrorMsgCleared() bool {
	_, ok := m.clearedFields[refund.FieldChannelErrorMsg]
	return ok
}

// ResetChannelErrorMsg resets all changes to the "channel_error_msg" field.
func (m *RefundMutation) ResetChannelErrorMsg() {
	m.channel_error_msg = nil
	delete(m.clearedFields, refund.FieldChannelErrorMsg)
}

// SetChannelNotifyData sets the "channel_notify_data" field.
func (m *RefundMutation) SetChannelNotifyData(s string) {
	m.channel_notify_data = &s
}

// ChannelNotifyData returns the value of the "channel_notify_data" field in the mutation.
func (m *RefundMutation) ChannelNotifyData() (r string, exists bool) {
	v := m.channel_notify_data
	if v == nil {
		return
	}
	return *v, true
}

// OldChannelNotifyData returns the old "channel_notify_data" field's value of the Refund entity.
// If the Refund object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RefundMutation) OldChannelNotifyData(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldChannelNotifyData is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldChannelNotifyData requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldChannelNotifyData: %w", err)
	}
	return oldValue.ChannelNotifyData, nil
}

// ClearChannelNotifyData clears the value of the "channel_notify_data" field.
func (m *RefundMutation) ClearChannelNotifyData() {
	m.channel_notify_data = nil
	m.clearedFields[refund.FieldChannelNotifyData] = struct{}{}
}

// ChannelNotifyDataCleared returns if the "channel_notify_data" field was cleared in this mutation.
func (m *RefundMutation) ChannelNotifyDataCleared() bool {
	_, ok := m.clearedFields[refund.FieldChannelNotifyData]
	return ok
}

// ResetChannelNotifyData resets all changes to the "channel_notify_data" field.
func (m *RefundMutation) ResetChannelNotifyData() {
	m.channel_notify_data = nil
	delete(m.clearedFields, refund.FieldChannelNotifyData)
}

// Where appends a list predicates to the RefundMutation builder.
func (m *RefundMutation) Where(ps ...predicate.Refund) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the RefundMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *RefundMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Refund, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *RefundMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *RefundMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Refund).
func (m *RefundMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *RefundMutation) Fields() []string {
	fields := make([]string, 0, 23)
	if m.created_at != nil {
		fields = append(fields, refund.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, refund.FieldUpdatedAt)
	}
	if m.status != nil {
		fields = append(fields, refund.FieldStatus)
	}
	if m.deleted_at != nil {
		fields = append(fields, refund.FieldDeletedAt)
	}
	if m.no != nil {
		fields = append(fields, refund.FieldNo)
	}
	if m.app_id != nil {
		fields = append(fields, refund.FieldAppID)
	}
	if m.channel_id != nil {
		fields = append(fields, refund.FieldChannelID)
	}
	if m.channel_code != nil {
		fields = append(fields, refund.FieldChannelCode)
	}
	if m.order_id != nil {
		fields = append(fields, refund.FieldOrderID)
	}
	if m.order_no != nil {
		fields = append(fields, refund.FieldOrderNo)
	}
	if m.merchant_order_id != nil {
		fields = append(fields, refund.FieldMerchantOrderID)
	}
	if m.merchant_refund_id != nil {
		fields = append(fields, refund.FieldMerchantRefundID)
	}
	if m.notify_url != nil {
		fields = append(fields, refund.FieldNotifyURL)
	}
	if m.pay_price != nil {
		fields = append(fields, refund.FieldPayPrice)
	}
	if m.refund_price != nil {
		fields = append(fields, refund.FieldRefundPrice)
	}
	if m.reason != nil {
		fields = append(fields, refund.FieldReason)
	}
	if m.user_ip != nil {
		fields = append(fields, refund.FieldUserIP)
	}
	if m.channel_order_no != nil {
		fields = append(fields, refund.FieldChannelOrderNo)
	}
	if m.channel_refund_no != nil {
		fields = append(fields, refund.FieldChannelRefundNo)
	}
	if m.success_time != nil {
		fields = append(fields, refund.FieldSuccessTime)
	}
	if m.channel_error_code != nil {
		fields = append(fields, refund.FieldChannelErrorCode)
	}
	if m.channel_error_msg != nil {
		fields = append(fields, refund.FieldChannelErrorMsg)
	}
	if m.channel_notify_data != nil {
		fields = append(fields, refund.FieldChannelNotifyData)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *RefundMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case refund.FieldCreatedAt:
		return m.CreatedAt()
	case refund.FieldUpdatedAt:
		return m.UpdatedAt()
	case refund.FieldStatus:
		return m.Status()
	case refund.FieldDeletedAt:
		return m.DeletedAt()
	case refund.FieldNo:
		return m.No()
	case refund.FieldAppID:
		return m.AppID()
	case refund.FieldChannelID:
		return m.ChannelID()
	case refund.FieldChannelCode:
		return m.ChannelCode()
	case refund.FieldOrderID:
		return m.OrderID()
	case refund.FieldOrderNo:
		return m.OrderNo()
	case refund.FieldMerchantOrderID:
		return m.MerchantOrderID()
	case refund.FieldMerchantRefundID:
		return m.MerchantRefundID()
	case refund.FieldNotifyURL:
		return m.NotifyURL()
	case refund.FieldPayPrice:
		return m.PayPrice()
	case refund.FieldRefundPrice:
		return m.RefundPrice()
	case refund.FieldReason:
		return m.Reason()
	case refund.FieldUserIP:
		return m.UserIP()
	case refund.FieldChannelOrderNo:
		return m.ChannelOrderNo()
	case refund.FieldChannelRefundNo:
		return m.ChannelRefundNo()
	case refund.FieldSuccessTime:
		return m.SuccessTime()
	case refund.FieldChannelErrorCode:
		return m.ChannelErrorCode()
	case refund.FieldChannelErrorMsg:
		return m.ChannelErrorMsg()
	case refund.FieldChannelNotifyData:
		return m.ChannelNotifyData()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *RefundMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case refund.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case refund.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case refund.FieldStatus:
		return m.OldStatus(ctx)
	case refund.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case refund.FieldNo:
		return m.OldNo(ctx)
	case refund.FieldAppID:
		return m.OldAppID(ctx)
	case refund.FieldChannelID:
		return m.OldChannelID(ctx)
	case refund.FieldChannelCode:
		return m.OldChannelCode(ctx)
	case refund.FieldOrderID:
		return m.OldOrderID(ctx)
	case refund.FieldOrderNo:
		return m.OldOrderNo(ctx)
	case refund.FieldMerchantOrderID:
		return m.OldMerchantOrderID(ctx)
	case refund.FieldMerchantRefundID:
		return m.OldMerchantRefundID(ctx)
	case refund.FieldNotifyURL:
		return m.OldNotifyURL(ctx)
	case refund.FieldPayPrice:
		return m.OldPayPrice(ctx)
	case refund.FieldRefundPrice:
		return m.OldRefundPrice(ctx)
	case refund.FieldReason:
		return m.OldReason(ctx)
	case refund.FieldUserIP:
		return m.OldUserIP(ctx)
	case refund.FieldChannelOrderNo:
		return m.OldChannelOrderNo(ctx)
	case refund.FieldChannelRefundNo:
		return m.OldChannelRefundNo(ctx)
	case refund.FieldSuccessTime:
		return m.OldSuccessTime(ctx)
	case refund.FieldChannelErrorCode:
		return m.OldChannelErrorCode(ctx)
	case refund.FieldChannelErrorMsg:
		return m.OldChannelErrorMsg(ctx)
	case refund.FieldChannelNotifyData:
		return m.OldChannelNotifyData(ctx)
	}
	return nil, fmt.Errorf("unknown Refund field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *RefundMutation) SetField(name string, value ent.Value) error {
	switch name {
	case refund.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case refund.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case refund.FieldStatus:
		v, ok := value.(uint8)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatus(v)
		return nil
	case refund.FieldDeletedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case refund.FieldNo:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetNo(v)
		return nil
	case refund.FieldAppID:
		v, ok := value.(uint64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAppID(v)
		return nil
	case refund.FieldChannelID:
		v, ok := value.(uint64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetChannelID(v)
		return nil
	case refund.FieldChannelCode:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetChannelCode(v)
		return nil
	case refund.FieldOrderID:
		v, ok := value.(uint64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOrderID(v)
		return nil
	case refund.FieldOrderNo:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOrderNo(v)
		return nil
	case refund.FieldMerchantOrderID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMerchantOrderID(v)
		return nil
	case refund.FieldMerchantRefundID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMerchantRefundID(v)
		return nil
	case refund.FieldNotifyURL:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetNotifyURL(v)
		return nil
	case refund.FieldPayPrice:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPayPrice(v)
		return nil
	case refund.FieldRefundPrice:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRefundPrice(v)
		return nil
	case refund.FieldReason:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetReason(v)
		return nil
	case refund.FieldUserIP:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUserIP(v)
		return nil
	case refund.FieldChannelOrderNo:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetChannelOrderNo(v)
		return nil
	case refund.FieldChannelRefundNo:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetChannelRefundNo(v)
		return nil
	case refund.FieldSuccessTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSuccessTime(v)
		return nil
	case refund.FieldChannelErrorCode:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetChannelErrorCode(v)
		return nil
	case refund.FieldChannelErrorMsg:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetChannelErrorMsg(v)
		return nil
	case refund.FieldChannelNotifyData:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetChannelNotifyData(v)
		return nil
	}
	return fmt.Errorf("unknown Refund field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *RefundMutation) AddedFields() []string {
	var fields []string
	if m.addstatus != nil {
		fields = append(fields, refund.FieldStatus)
	}
	if m.addapp_id != nil {
		fields = append(fields, refund.FieldAppID)
	}
	if m.addchannel_id != nil {
		fields = append(fields, refund.FieldChannelID)
	}
	if m.addorder_id != nil {
		fields = append(fields, refund.FieldOrderID)
	}
	if m.addpay_price != nil {
		fields = append(fields, refund.FieldPayPrice)
	}
	if m.addrefund_price != nil {
		fields = append(fields, refund.FieldRefundPrice)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *RefundMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case refund.FieldStatus:
		return m.AddedStatus()
	case refund.FieldAppID:
		return m.AddedAppID()
	case refund.FieldChannelID:
		return m.AddedChannelID()
	case refund.FieldOrderID:
		return m.AddedOrderID()
	case refund.FieldPayPrice:
		return m.AddedPayPrice()
	case refund.FieldRefundPrice:
		return m.AddedRefundPrice()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *RefundMutation) AddField(name string, value ent.Value) error {
	switch name {
	case refund.FieldStatus:
		v, ok := value.(int8)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddStatus(v)
		return nil
	case refund.FieldAppID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddAppID(v)
		return nil
	case refund.FieldChannelID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddChannelID(v)
		return nil
	case refund.FieldOrderID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddOrderID(v)
		return nil
	case refund.FieldPayPrice:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddPayPrice(v)
		return nil
	case refund.FieldRefundPrice:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddRefundPrice(v)
		return nil
	}
	return fmt.Errorf("unknown Refund numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *RefundMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(refund.FieldStatus) {
		fields = append(fields, refund.FieldStatus)
	}
	if m.FieldCleared(refund.FieldDeletedAt) {
		fields = append(fields, refund.FieldDeletedAt)
	}
	if m.FieldCleared(refund.FieldUserIP) {
		fields = append(fields, refund.FieldUserIP)
	}
	if m.FieldCleared(refund.FieldChannelRefundNo) {
		fields = append(fields, refund.FieldChannelRefundNo)
	}
	if m.FieldCleared(refund.FieldSuccessTime) {
		fields = append(fields, refund.FieldSuccessTime)
	}
	if m.FieldCleared(refund.FieldChannelErrorCode) {
		fields = append(fields, refund.FieldChannelErrorCode)
	}
	if m.FieldCleared(refund.FieldChannelErrorMsg) {
		fields = append(fields, refund.FieldChannelErrorMsg)
	}
	if m.FieldCleared(refund.FieldChannelNotifyData) {
		fields = append(fields, refund.FieldChannelNotifyData)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *RefundMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *RefundMutation) ClearField(name string) error {
	switch name {
	case refund.FieldStatus:
		m.ClearStatus()
		return nil
	case refund.FieldDeletedAt:
		m.ClearDeletedAt()
		return nil
	case refund.FieldUserIP:
		m.ClearUserIP()
		return nil
	case refund.FieldChannelRefundNo:
		m.ClearChannelRefundNo()
		return nil
	case refund.FieldSuccessTime:
		m.ClearSuccessTime()
		return nil
	case refund.FieldChannelErrorCode:
		m.ClearChannelErrorCode()
		return nil
	case refund.FieldChannelErrorMsg:
		m.ClearChannelErrorMsg()
		return nil
	case refund.FieldChannelNotifyData:
		m.ClearChannelNotifyData()
		return nil
	}
	return fmt.Errorf("unknown Refund nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *RefundMutation) ResetField(name string) error {
	switch name {
	case refund.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case refund.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case refund.FieldStatus:
		m.ResetStatus()
		return nil
	case refund.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case refund.FieldNo:
		m.ResetNo()
		return nil
	case refund.FieldAppID:
		m.ResetAppID()
		return nil
	case refund.FieldChannelID:
		m.ResetChannelID()
		return nil
	case refund.FieldChannelCode:
		m.ResetChannelCode()
		return nil
	case refund.FieldOrderID:
		m.ResetOrderID()
		return nil
	case refund.FieldOrderNo:
		m.ResetOrderNo()
		return nil
	case refund.FieldMerchantOrderID:
		m.ResetMerchantOrderID()
		return nil
	case refund.FieldMerchantRefundID:
		m.ResetMerchantRefundID()
		return nil
	case refund.FieldNotifyURL:
		m.ResetNotifyURL()
		return nil
	case refund.FieldPayPrice:
		m.ResetPayPrice()
		return nil
	case refund.FieldRefundPrice:
		m.ResetRefundPrice()
		return nil
	case refund.FieldReason:
		m.ResetReason()
		return nil
	case refund.FieldUserIP:
		m.ResetUserIP()
		return nil
	case refund.FieldChannelOrderNo:
		m.ResetChannelOrderNo()
		return nil
	case refund.FieldChannelRefundNo:
		m.ResetChannelRefundNo()
		return nil
	case refund.FieldSuccessTime:
		m.ResetSuccessTime()
		return nil
	case refund.FieldChannelErrorCode:
		m.ResetChannelErrorCode()
		return nil
	case refund.FieldChannelErrorMsg:
		m.ResetChannelErrorMsg()
		return nil
	case refund.FieldChannelNotifyData:
		m.ResetChannelNotifyData()
		return nil
	}
	return fmt.Errorf("unknown Refund field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *RefundMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *RefundMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *RefundMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *RefundMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *RefundMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *RefundMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *RefundMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown Refund unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *RefundMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown Refund edge %s", name)
}
